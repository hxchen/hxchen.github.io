<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>我不是帅才</title>
    <link>https://www.3afun.com/</link>
    <description>Recent content on 我不是帅才</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://www.3afun.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://www.3afun.com/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://www.3afun.com/about/</guid>
      
        <description>&lt;p&gt;Geeking &amp;amp; Hiking&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ubuntu16.04 搭建以太坊Ethereum私链(2)</title>
      <link>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE2/</link>
      <pubDate>Fri, 13 Apr 2018 16:18:49 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE2/</guid>
      
        <description>

&lt;p&gt;前面几篇文章我们介绍了私有链的服务器搭建和客户端连接私有服务器,接下来我们就要学习如何保证服务器端退出后还能继续提供稳定服务,解决客户端可以永久链接服务器,交易实时被处理。&lt;/p&gt;

&lt;h1 id=&#34;服务器端启动&#34;&gt;服务器端启动&lt;/h1&gt;

&lt;p&gt;为了让客户端可以链接,我们可以使用nohup命令来让服务器进行后台启动,但仅仅这样还是不够的,我们还应该允许服务器端支持客户端转账等API,我们就要使用&lt;code&gt;--rpcapi&lt;/code&gt; 参数来指定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup geth --identity TestNode --rpc --rpcaddr 0.0.0.0 --rpcport 8545 --rpcapi &amp;quot;db,eth,net,web3,personal,admin,miner&amp;quot; --datadir /home/ubuntu/ethereum/data0 --port 30303 --nodiscover --mine --minerthreads=1 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令可以来后台启动服务器,并且允许客户端进行远程API调用.
在此命令中我们使用了mine参数开启一个线程进行挖矿,我们是有理由这么操作的,因为如果不是这样,即使客户端发起了一笔远程交易,因为不能生产块数据,也还是不会处理转账。&lt;/p&gt;

&lt;p&gt;如果你还是想进入console控制台来向原来那样执行命令,可以使用如下命令来进入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth attach http://127.0.0.1:8545
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这篇文章结束后,我们在使用客户端操作时候,就可以实现实时处理我们的交易。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ethereum wallet以太坊钱包链接Geth Server私有链</title>
      <link>https://www.3afun.com/post/2018/ethereum-wallet%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E9%93%BE%E6%8E%A5geth-server%E7%A7%81%E6%9C%89%E9%93%BE/</link>
      <pubDate>Thu, 12 Apr 2018 18:31:44 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/ethereum-wallet%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E9%93%BE%E6%8E%A5geth-server%E7%A7%81%E6%9C%89%E9%93%BE/</guid>
      
        <description>

&lt;p&gt;上一篇文章里,我们讲到 &lt;a href=&#34;https://www.3afun.com/post/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE/&#34;&gt;Ubuntu16.04 搭建以太坊Ethereum私链&lt;/a&gt;
这次,我就要来介绍如何下载我们的钱包来链接我们的私有链。&lt;/p&gt;

&lt;h1 id=&#34;以太坊钱包wallet下载&#34;&gt;以太坊钱包Wallet下载&lt;/h1&gt;

&lt;p&gt;钱包下载,大家可以去 &lt;a href=&#34;https://github.com/ethereum/mist/releases&#34;&gt;这里&lt;/a&gt;下载。现在最新版本是0.10.0&lt;/p&gt;

&lt;p&gt;不管大家选择是 Ethereum Wallet 还是 Mist 都是可以的,这里我都下载了Mac版本的2个钱包。&lt;/p&gt;

&lt;p&gt;安装的话没有难度,正常安装就行。&lt;/p&gt;

&lt;h1 id=&#34;geth-server-私有链服务器端&#34;&gt;Geth Server 私有链服务器端&lt;/h1&gt;

&lt;p&gt;因为我是远程链接私有链不是本地链接,所有我采用了RPC 链接方式。&lt;/p&gt;

&lt;p&gt;Geth 启动方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth --identity &amp;quot;TestNode&amp;quot; --rpc --rpcaddr &amp;quot;0.0.0.0&amp;quot; --rpcport &amp;quot;8545&amp;quot; --datadir data0 --port &amp;quot;30303&amp;quot; --nodiscover console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此次我们加入了 &lt;code&gt;--rpcaddr&lt;/code&gt;参数来允许远程连接,默认是拒绝远程链接的,只能本地链接。&lt;/p&gt;

&lt;h1 id=&#34;客户端钱包wallet启动&#34;&gt;客户端钱包Wallet启动&lt;/h1&gt;

&lt;h3 id=&#34;ethereum-wallet-启动&#34;&gt;Ethereum Wallet 启动&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;/Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet&amp;quot; --rpc &amp;quot;http://YOUR_IP:8545&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mist-启动&#34;&gt;Mist 启动&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/Applications/Mist.app/Contents/MacOS/Mist --rpc http://YOUR_IP:8545
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请自行替换 &lt;code&gt;YOUR_IP&lt;/code&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ubuntu16.04 搭建以太坊Ethereum私链</title>
      <link>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE1/</link>
      <pubDate>Wed, 11 Apr 2018 15:43:48 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE1/</guid>
      
        <description>

&lt;h1 id=&#34;一-说明&#34;&gt;一、说明&lt;/h1&gt;

&lt;p&gt;想尝试基于以太坊的应用或者Tokens发布，无奈正常网络测试需要用Ether，购买麻烦，各步骤还得需要消耗以太币，不过我们可以搭建私有链来进行开发，话不多说，马上开始搭建我们自己的开发测试私有链。&lt;/p&gt;

&lt;h1 id=&#34;二-所需工具&#34;&gt;二、所需工具&lt;/h1&gt;

&lt;p&gt;1、以太坊客户端&lt;/p&gt;

&lt;p&gt;以太坊客户端用于接入以太坊网络，进行账户管理、交易、挖矿、智能合约相关的操作。&lt;/p&gt;

&lt;p&gt;目前有多种语言实现的客户端，常用的有 Go 语言实现的 go-ethereum 客户端 Geth，支持接入以太坊网络并成为一个完整节点，也可作为一个 HTTP-RPC 服务器对外提供 JSON-RPC 接口。&lt;/p&gt;

&lt;p&gt;其他的客户端有：智能合约编译器&lt;/p&gt;

&lt;p&gt;Parity：Rust 语言实现；&lt;/p&gt;

&lt;p&gt;cpp-ethereum：C++ 语言实现；&lt;/p&gt;

&lt;p&gt;ethereumjs-lib：JavaScript 语言实现；&lt;/p&gt;

&lt;p&gt;Ethereum(J)：Java 语言实现；&lt;/p&gt;

&lt;p&gt;ethereumH：Haskell 语言实现；&lt;/p&gt;

&lt;p&gt;pyethapp： Python 语言实现；&lt;/p&gt;

&lt;p&gt;ruby-ethereum：Ruby 语言实现；&lt;/p&gt;

&lt;p&gt;2、智能合约编译器&lt;/p&gt;

&lt;p&gt;以太坊支持两种智能合约的编程语言：Solidity 和 Serpent。现在的主流是Solidity，学习教程可参考 &lt;a href=&#34;http://www.tryblockchain.org/Solidity-%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D.html&#34;&gt;站点&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;现在以太坊提供更方便的在线 IDE —— Remix &lt;a href=&#34;https://remix.ethereum.org&#34;&gt;https://remix.ethereum.org&lt;/a&gt; 使用 Remix，免去了安装solc和编译过程，它可以直接提供部署合约所需的二进制码和 ABI。&lt;/p&gt;

&lt;p&gt;3、以太坊钱包&lt;/p&gt;

&lt;p&gt;以太坊提供了图形界面的钱包 Ethereum Wallet 和 Mist Dapp 浏览器。&lt;/p&gt;

&lt;p&gt;钱包的功能是 Mist 的一个子集，可用于管理账户和交易；Mist 在钱包基础上，还能操作智能合约。为了演示合约部署过程，本文使用了 Geth console 操作，没有用到 Mist，当然，使用 Mist 会更简单。&lt;/p&gt;

&lt;h1 id=&#34;三-安装&#34;&gt;三、安装&lt;/h1&gt;

&lt;p&gt;服务器我们采用Ubuntu16.04。&lt;/p&gt;

&lt;p&gt;首先安装必要的工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt install software-properties-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次添加以太坊源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-apt-repository -y ppa:ethereum/ethereum
apt update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后安装go-ethereum&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt install ethereum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，可以运行命令查看是否成功&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Geth
Version: 1.8.2-stable
Git Commit: b8b9f7f4476a30a0aaf6077daade6ae77f969960
Architecture: amd64
Protocol Versions: [63 62]
Network Id: 1
Go Version: go1.9.4
Operating System: linux
GOPATH=
GOROOT=/usr/lib/go-1.9
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-私有链搭建&#34;&gt;四、私有链搭建&lt;/h1&gt;

&lt;p&gt;1、创建初始化配置文件和存放数据目录&lt;/p&gt;

&lt;p&gt;要运行以太坊私有链，需要定义自己创世区块，创世区块是一个json格式配置文件。我们可以新建一个文件 genesis.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
&amp;quot;config&amp;quot;: {
    &amp;quot;chainId&amp;quot;: 411,
    &amp;quot;homesteadBlock&amp;quot;: 0,
    &amp;quot;eip155Block&amp;quot;: 0,
    &amp;quot;eip158Block&amp;quot;: 0
  },
  &amp;quot;nonce&amp;quot;: &amp;quot;0x0000000000000033&amp;quot;,
  &amp;quot;timestamp&amp;quot;: &amp;quot;0x0&amp;quot;,
  &amp;quot;parentHash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;gasLimit&amp;quot;: &amp;quot;0x8000000&amp;quot;,
  &amp;quot;difficulty&amp;quot;: &amp;quot;0x100&amp;quot;,
  &amp;quot;mixhash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;coinbase&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;alloc&amp;quot;: {
        &amp;quot;0x1C83C95473e1e93A2C8560c73976dAFA9C3f0a79&amp;quot;:{&amp;quot;balance&amp;quot;:&amp;quot;1000000&amp;quot;}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中chainID 指定了区块链网络ID。&lt;/p&gt;

&lt;p&gt;并且我对自己地址进行了配额。其他参数可参考 &lt;a href=&#34;http://www.tryblockchain.org/Solidity-%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D.html&#34;&gt;站点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;存放数据目录在此我使用 &lt;code&gt;/home/ubuntu/ethereum/data0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;genesis.json存放在&lt;code&gt;/home/ubuntu/ethereum/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后可以执行命令来进行初始化操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ethereum
geth --datadir data0 init genesis.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INFO [04-11|07:51:14] Maximum peer count                       ETH=25 LES=0 total=25
INFO [04-11|07:51:14] Allocated cache and file handles         database=/home/ubuntu/ethereum/data0/geth/chaindata cache=16 handles=16
INFO [04-11|07:51:14] Writing custom genesis block
INFO [04-11|07:51:14] Persisted trie from memory database      nodes=1 size=195.00B time=35.174碌s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [04-11|07:51:14] Successfully wrote genesis state         database=chaindata                                  hash=b924d6Ωfdceb
INFO [04-11|07:51:14] Allocated cache and file handles         database=/home/ubuntu/ethereum/data0/geth/lightchaindata cache=16 handles=16
INFO [04-11|07:51:14] Writing custom genesis block
INFO [04-11|07:51:14] Persisted trie from memory database      nodes=1 size=195.00B time=460.134碌s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [04-11|07:51:14] Successfully wrote genesis state         database=lightchaindata                                  hash=b924d6Ωfdceb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化成功后，会在data0目录下生产所需文件。&lt;/p&gt;

&lt;p&gt;其中 &lt;code&gt;geth/chaindata&lt;/code&gt; 中存放的是区块数据，&lt;code&gt;keystore&lt;/code&gt; 中存放的是账户数据。&lt;/p&gt;

&lt;h1 id=&#34;五-启动私有节点&#34;&gt;五、启动私有节点&lt;/h1&gt;

&lt;p&gt;初始化完成后，就有了一条自己的私有链。我们可以执行命令来启动它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth --identity &amp;quot;TestNode&amp;quot; --rpc --rpcport &amp;quot;8545&amp;quot; --datadir data0 --port &amp;quot;30303&amp;quot; --nodiscover console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令的主体是 geth console，表示启动节点并进入交互式控制台。&lt;/p&gt;

&lt;p&gt;各选项含义如下：&lt;/p&gt;

&lt;p&gt;–identity：指定节点 ID；&lt;/p&gt;

&lt;p&gt;–rpc：表示开启 HTTP-RPC 服务；&lt;/p&gt;

&lt;p&gt;–rpcport：指定 HTTP-RPC 服务监听端口号（默认为 8545）；&lt;/p&gt;

&lt;p&gt;–datadir：指定区块链数据的存储位置；&lt;/p&gt;

&lt;p&gt;–port：指定和其他节点连接所用的端口号（默认为 30303）；&lt;/p&gt;

&lt;p&gt;–nodiscover：关闭节点发现机制，防止加入有同样初始配置的陌生节点。&lt;/p&gt;

&lt;p&gt;运行上面的命令后，就启动了区块链节点并进入了该节点的控制台：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INFO [04-11|08:05:23] Maximum peer count                       ETH=25 LES=0 total=25
INFO [04-11|08:05:23] Starting peer-to-peer node               instance=Geth/TestNode/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4
INFO [04-11|08:05:23] Allocated cache and file handles         database=/home/ubuntu/ethereum/data0/data0/geth/chaindata cache=768 handles=512
INFO [04-11|08:05:23] Writing default main-net genesis block
INFO [04-11|08:05:23] Persisted trie from memory database      nodes=12356 size=2.34mB time=47.705254ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [04-11|08:05:23] Initialised chain configuration          config=&amp;quot;{ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Byzantium: 4370000 Constantinople: &amp;lt;nil&amp;gt; Engine: ethash}&amp;quot;
INFO [04-11|08:05:23] Disk storage enabled for ethash caches   dir=/home/ubuntu/ethereum/data0/data0/geth/ethash count=3
INFO [04-11|08:05:23] Disk storage enabled for ethash DAGs     dir=/root/.ethash                                 count=2
INFO [04-11|08:05:23] Initialising Ethereum protocol           versions=&amp;quot;[63 62]&amp;quot; network=1
INFO [04-11|08:05:23] Loaded most recent local header          number=0 hash=d4e567b8fa3 td=17179869184
INFO [04-11|08:05:23] Loaded most recent local full block      number=0 hash=d4e567b8fa3 td=17179869184
INFO [04-11|08:05:23] Loaded most recent local fast block      number=0 hash=d4e567b8fa3 td=17179869184
INFO [04-11|08:05:23] Regenerated local transaction journal    transactions=0 accounts=0
INFO [04-11|08:05:23] Starting P2P networking
INFO [04-11|08:05:23] RLPx listener up                         self=&amp;quot;enode://b5e91ca148308d721599ac14b9f2a9aff28c88b258a439fbc19f094d65ecaa9954a6a7d0de29f5737726bcdb20a443db9edeedce0471c1ba5cda043e8601e0d0@[::]:30303?discport=0&amp;quot;
INFO [04-11|08:05:23] IPC endpoint opened                      url=/home/ubuntu/ethereum/data0/data0/geth.ipc
INFO [04-11|08:05:23] HTTP endpoint opened                     url=http://127.0.0.1:8545                      cors= vhosts=localhost
Welcome to the Geth JavaScript console!

instance: Geth/TestNode/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个交互式的 JavaScript 执行环境，在这里面可以执行 JavaScript 代码，其中 &lt;code&gt;&amp;gt;&lt;/code&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的 JavaScript 对象，可以直接使用这些对象。这些对象主要包括：&lt;/p&gt;

&lt;p&gt;eth：包含一些跟操作区块链相关的方法；&lt;/p&gt;

&lt;p&gt;net：包含一些查看p2p网络状态的方法；&lt;/p&gt;

&lt;p&gt;admin：包含一些与管理节点相关的方法；&lt;/p&gt;

&lt;p&gt;miner：包含启动&amp;amp;停止挖矿的一些方法；&lt;/p&gt;

&lt;p&gt;personal：主要包含一些管理账户的方法；&lt;/p&gt;

&lt;p&gt;txpool：包含一些查看交易内存池的方法；&lt;/p&gt;

&lt;p&gt;web3：包含了以上对象，还包含一些单位换算的方法。&lt;/p&gt;

&lt;h1 id=&#34;六-控制台操作&#34;&gt;六、控制台操作&lt;/h1&gt;

&lt;p&gt;进入以太坊 Javascript Console 后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。&lt;/p&gt;

&lt;p&gt;常用命令有：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;personal.newAccount()&lt;/code&gt;：创建账户；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;personal.unlockAccount()&lt;/code&gt;：解锁账户；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.accounts&lt;/code&gt;：枚举系统中的账户；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.getBalance()&lt;/code&gt;：查看账户余额，返回值的单位是 Wei（Wei 是以太坊中最小货币面额单位，类似比特币中的聪，1 ether = 10^18 Wei）；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.blockNumber&lt;/code&gt;：列出区块总数；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.getTransaction()&lt;/code&gt;：获取交易；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.getBlock()&lt;/code&gt;：获取区块；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;miner.start()&lt;/code&gt;：开始挖矿；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;miner.stop()&lt;/code&gt;：停止挖矿；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;web3.fromWei()&lt;/code&gt;：Wei 换算成以太币；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;web3.toWei()&lt;/code&gt;：以太币换算成 Wei；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;txpool.status&lt;/code&gt;：交易池中的状态；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;admin.addPeer()&lt;/code&gt;：连接到其他节点；&lt;/p&gt;

&lt;p&gt;这些命令支持 Tab 键自动补全，具体用法如下。&lt;/p&gt;

&lt;h2 id=&#34;1-创建账户&#34;&gt;1、创建账户&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;personal.newAccount()
Passphrase:
Repeat passphrase:
&amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入密码、确认密码将会创建一个账户.&lt;/p&gt;

&lt;p&gt;同样方法再创建一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; personal.newAccount()
Passphrase:
Repeat passphrase:
&amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看账户(上面初始化配置文件出差错了？没分配呀)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.accounts
[&amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;, &amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-查看账户余额&#34;&gt;2、查看账户余额&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;eth.getBalance(eth.accounts[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-启动-停止挖矿&#34;&gt;3、启动 停止挖矿&lt;/h2&gt;

&lt;h3 id=&#34;启动挖矿&#34;&gt;启动挖矿&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;miner.start(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 start 的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的 DAG 文件，这个过程有点慢，等进度达到 100% 后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。&lt;/p&gt;

&lt;h3 id=&#34;停止挖矿&#34;&gt;停止挖矿&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;miner.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做 coinbase，默认情况下 coinbase 是本地账户中的第一个账户，可以通过 miner.setEtherbase() 将其他账户设置成 coinbase。&lt;/p&gt;

&lt;p&gt;再次查看账户余额&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
510000000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-发送交易&#34;&gt;4、发送交易&lt;/h2&gt;

&lt;p&gt;目前，账户0已经挖到了97个块的奖励，账户1余额还是0：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
510000000000000000000
&amp;gt; eth.getBalance(eth.accounts[1])
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们要从账户0到账户1转账，需要先解锁账户0才能转账&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; personal.unlockAccount(eth.accounts[0])
Unlock account 0x914995c9c3c993c9d3fdd63602c91823f932b308
Passphrase:
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转账0-&amp;gt;1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; amount = web3.toWei(5,&#39;ether&#39;)
&amp;quot;5000000000000000000&amp;quot;
&amp;gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})
INFO [04-11|09:37:09] Submitted transaction                    fullhash=0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973 recipient=0x30Ed8Cd207dfdAF5E24847252DF822b1DA1F2FE5
&amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时如果没有挖矿，用 txpool.status 命令可以看到本地交易池中有一个待确认的交易，可以使用 &lt;code&gt;eth.getBlock(&amp;quot;pending&amp;quot;, true).transactions&lt;/code&gt; 查看当前待确认交易。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; txpool.status
{
  pending: 1,
  queued: 0
}
&amp;gt; eth.getBlock(&amp;quot;pending&amp;quot;, true).transactions
[{
    blockHash: &amp;quot;0x2a13705bbe3a60c1d8fa686d6c8a326c6f1b70e7943bb7be8d8e9aa9fef7701e&amp;quot;,
    blockNumber: 103,
    from: &amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;,
    gas: 90000,
    gasPrice: 18000000000,
    hash: &amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;,
    input: &amp;quot;0x&amp;quot;,
    nonce: 0,
    r: &amp;quot;0x546055f53f1f7535549c4e31ddf03c6678384afc9571240d237823c205239a11&amp;quot;,
    s: &amp;quot;0x65f39c6a35f338c6fe67faf7a3bb14c91abc0472113bb9916c82cc51a407f6c9&amp;quot;,
    to: &amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;,
    transactionIndex: 0,
    v: &amp;quot;0x359&amp;quot;,
    value: 5000000000000000000
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;miner.start()&lt;/code&gt; 命令开始挖矿：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; miner.start(1);admin.sleepBlocks(1);miner.stop();
INFO [04-11|09:39:49] Updated mining threads                   threads=1
INFO [04-11|09:39:49] Transaction pool price threshold updated price=18000000000
INFO [04-11|09:39:49] Starting mining operation
INFO [04-11|09:39:49] Commit new mining work                   number=103 txs=1 uncles=0 elapsed=378.402碌s
INFO [04-11|09:39:52] Successfully sealed new block            number=103 hash=8327606bec9
INFO [04-11|09:39:52]  block reached canonical chain          number=98  hash=9d43b286588
INFO [04-11|09:39:52]  mined potential block                  number=103 hash=8327606bec9
INFO [04-11|09:39:52] Commit new mining work                   number=104 txs=0 uncles=0 elapsed=231.591碌s
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新区块挖出后，挖矿结束，查看账户 1 的余额，已经收到了账户 0 的以太币：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&#39;ether&#39;)
5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-查看交易和区块&#34;&gt;5、查看交易和区块&lt;/h2&gt;

&lt;p&gt;查看当前区块总数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.blockNumber
103
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过交易 Hash 查看交易（Hash 值包含在上面交易返回值中）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getTransaction(&amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;)
{
  blockHash: &amp;quot;0x83276067a8ad0168cf1d9fabb089b7778024bc6700434f470d830decb4a6bec9&amp;quot;,
  blockNumber: 103,
  from: &amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;,
  gas: 90000,
  gasPrice: 18000000000,
  hash: &amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;,
  input: &amp;quot;0x&amp;quot;,
  nonce: 0,
  r: &amp;quot;0x546055f53f1f7535549c4e31ddf03c6678384afc9571240d237823c205239a11&amp;quot;,
  s: &amp;quot;0x65f39c6a35f338c6fe67faf7a3bb14c91abc0472113bb9916c82cc51a407f6c9&amp;quot;,
  to: &amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;,
  transactionIndex: 0,
  v: &amp;quot;0x359&amp;quot;,
  value: 5000000000000000000
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过区块号查看区块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getBlock(102)
{
  difficulty: 137514,
  extraData: &amp;quot;0xd783010802846765746887676f312e392e34856c696e7578&amp;quot;,
  gasLimit: 121486905,
  gasUsed: 0,
  hash: &amp;quot;0x09c0a05f1a76fa39222f965d0b3665550bb5a0ab518963c8d1c5280a7b13cf43&amp;quot;,
  logsBloom: &amp;quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  miner: &amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;,
  mixHash: &amp;quot;0x7afd2e352e797ad57554bd81d1f156baed041242fcb641c336683fc9f5937b6c&amp;quot;,
  nonce: &amp;quot;0x4fe257812731bb15&amp;quot;,
  number: 102,
  parentHash: &amp;quot;0xaf1c22536346d8183b63632e4eb6fae81bfd5f9ca305f5fe20b9b7ef0da2a9de&amp;quot;,
  receiptsRoot: &amp;quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&amp;quot;,
  sha3Uncles: &amp;quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&amp;quot;,
  size: 536,
  stateRoot: &amp;quot;0x73bb0a88af2d04b4fcec031a48ffdc16cda90b88c215e3587f1e9acc1c050eca&amp;quot;,
  timestamp: 1523438740,
  totalDifficulty: 13695386,
  transactions: [],
  transactionsRoot: &amp;quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&amp;quot;,
  uncles: []
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>ERC223 标准规范</title>
      <link>https://www.3afun.com/post/2018/erc-223-token-standard/</link>
      <pubDate>Mon, 09 Apr 2018 15:43:48 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/erc-223-token-standard/</guid>
      
        <description>

&lt;p&gt;翻译自 &lt;a href=&#34;https://github.com/ethereum/EIPs/issues/223&#34;&gt;https://github.com/ethereum/EIPs/issues/223&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;抽象&#34;&gt;抽象&lt;/h1&gt;

&lt;p&gt;以下描述了标准代币合约函数和特定的代币,这样的实现代币可以避免意外发送到合约,可以是代币事物表现的像其他事务一样。&lt;/p&gt;

&lt;h1 id=&#34;动机&#34;&gt;动机&lt;/h1&gt;

&lt;p&gt;以下描述了ER223解决的ERC20代币规范的问题:
ERC20代币规范会导致退出用户的金钱损失.主要的问题是无法处理传入的ERC20事务,该事务是指通过 ERC20规范中 &lt;code&gt;transfer&lt;/code&gt; 函数执行的。&lt;/p&gt;

&lt;p&gt;如果你发送100个 ETH到一个不支持Ether的合约地址,那么他会拒绝交易并没有什么坏事发生。
如果您发送100个 ERC20代币到一个不支持ERC20的代币合约地址,那么他不会被拒绝,因为它能识别传入事务,所以会导致你的代币在你的余额里被卡住。&lt;/p&gt;

&lt;p&gt;比起ERC20,ERC23里解决的是:&lt;/p&gt;

&lt;p&gt;1.缺少 &lt;code&gt;transfer&lt;/code&gt; 处理的可能性。&lt;/p&gt;

&lt;p&gt;2.代币丢失。&lt;/p&gt;

&lt;p&gt;3.代币交易应该符合以太坊思想。当一个用户想交易的时候,他应该一直是通过调用 &lt;code&gt;transfer&lt;/code&gt;.用户是存一个新合约还是发送给一个外部账户,这都是无关紧要的.&lt;/p&gt;

&lt;p&gt;这些讲允许合约处理传入的代币事务并且阻止意外发送的和合约接受的代币(卡在余额中)&lt;/p&gt;

&lt;p&gt;例如,去中心化的交易不再需要用户调用 &lt;code&gt;approve&lt;/code&gt; 然后调用 &lt;code&gt;deposit&lt;/code&gt;(内部调用 &lt;code&gt;transferFrom&lt;/code&gt;用来取出批准的代币). 代币事务会在交易合约中自动处理.&lt;/p&gt;

&lt;p&gt;这里最重要的是在执行合约时调用 &lt;code&gt;tokenFallback&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;规范&#34;&gt;规范&lt;/h1&gt;

&lt;h1 id=&#34;代币-tokens&#34;&gt;代币(Tokens)&lt;/h1&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;注意:合约开发者如果想他们的合约支持特定代币,那么他们必须实现&lt;code&gt;tokenFallback&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果接受者没有实现 &lt;code&gt;tokenFallback&lt;/code&gt;函数,考虑合约不是设计用来支持代币,那么交易必定失败并且不会有代币被转账.
类比以太币交易,当发送以太币到一个没有实现 &lt;code&gt;function() payable&lt;/code&gt;的合约地址,也是会失败。&lt;/p&gt;

&lt;h3 id=&#34;totalsupply&#34;&gt;totalSupply&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function totalSupply() constant returns (uint256 totalSupply)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回代币总量&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function name() constant returns (string _name)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回代币名字&lt;/p&gt;

&lt;h3 id=&#34;symbol&#34;&gt;symbol&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function symbol() constant returns (bytes32 _symbol)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回代币符号&lt;/p&gt;

&lt;h3 id=&#34;decimals&#34;&gt;decimals&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function decimals() constant returns (uint8 _decimals)&lt;/code&gt;
返回精度&lt;/p&gt;

&lt;h3 id=&#34;balanceof&#34;&gt;balanceOf&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function balanceOf(address _owner) constant returns (uint256 balance)&lt;/code&gt;
返回 address _owner 的余额&lt;/p&gt;

&lt;h3 id=&#34;transfer-address-uint&#34;&gt;transfer(address, uint)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function transfer(address _to, uint _value) returns (bool)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为 ERC20 &lt;code&gt;transfer&lt;/code&gt; 函数没有 &lt;code&gt;bytes&lt;/code&gt; 参数,所以需要向后兼容.
该函数必须必须传输令牌并调&lt;code&gt;_to&lt;/code&gt;中的函数&lt;code&gt;tokenFallback(address,uint256,bytes)&lt;/code&gt;。
如果&lt;code&gt;_to&lt;/code&gt;（接收方合同）中没有实现&lt;code&gt;tokenFallback&lt;/code&gt;函数，则事务必须失败，并且不会发生令牌的传输。&lt;/p&gt;

&lt;p&gt;注意:将在接收方合约中调用的令牌备用功能必须命名为&lt;code&gt;tokenFallback&lt;/code&gt;，并使用参数&lt;code&gt;address,uint256，bytes&lt;/code&gt;。 此函数必须具有0xc0ee0b8a签名。&lt;/p&gt;

&lt;h3 id=&#34;transfer-address-uint-bytes&#34;&gt;transfer(address, uint, bytes)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function transfer(address _to, uint _value, bytes _data) returns (bool)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该函数总是在某人想转移代币的时候调用。&lt;/p&gt;

&lt;h2 id=&#34;事件&#34;&gt;事件&lt;/h2&gt;

&lt;h3 id=&#34;transfer&#34;&gt;Transfer&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;转移代币时候触发.&lt;/p&gt;

&lt;h2 id=&#34;contract合约和tokens-代币-一起工作&#34;&gt;Contract合约和tokens 代币 一起工作&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;function tokenFallback(address _from, uint _value, bytes _data)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一个处理代币转移的函数,当代币持有者发送代币时候由代币合约来调用.
&lt;code&gt;_from&lt;/code&gt;指代币发送者 &lt;code&gt;_value&lt;/code&gt;是收入代币的数量,&lt;code&gt;_data&lt;/code&gt;是附加数据,类似于以太币交易中的&lt;code&gt;msg.data&lt;/code&gt;.
它类似于Ether事务的fallback功能，并且什么也不返回。&lt;/p&gt;

&lt;h2 id=&#34;推荐的实现&#34;&gt;推荐的实现&lt;/h2&gt;

&lt;p&gt;这是一个强烈推荐的ERC223的代币实现 &lt;a href=&#34;https://github.com/Dexaran/ERC23-tokens/tree/Recommended&#34;&gt;https://github.com/Dexaran/ERC23-tokens/tree/Recommended&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ERC20 标准规范</title>
      <link>https://www.3afun.com/post/2018/erc-20-token-standard/</link>
      <pubDate>Wed, 04 Apr 2018 15:43:48 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/erc-20-token-standard/</guid>
      
        <description>

&lt;h1 id=&#34;简要说明&#34;&gt;简要说明&lt;/h1&gt;

&lt;p&gt;该文主要是一个以太币智能合约的标准接口说明。&lt;/p&gt;

&lt;h1 id=&#34;抽象&#34;&gt;抽象&lt;/h1&gt;

&lt;p&gt;以下将要说明的标准允许你去实现基于智能合约的标准代币（Tokens）API提供的接口。这个标准提供了一些基本功能以用于代币（Tokens）转账，以及批准用于其他链上的第三方来使用。&lt;/p&gt;

&lt;h1 id=&#34;动机&#34;&gt;动机&lt;/h1&gt;

&lt;p&gt;标准接口允许以太坊上的任何代币（Tokens）可以被其他程序来重新使用：包括钱包和去中心化的交换。&lt;/p&gt;

&lt;h1 id=&#34;规范&#34;&gt;规范&lt;/h1&gt;

&lt;h1 id=&#34;代币-tokens&#34;&gt;代币(Tokens)&lt;/h1&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;注意：调用者必须处理返回方法 &lt;code&gt;returns (bool success)&lt;/code&gt;返回的 &lt;code&gt;false&lt;/code&gt;.调用者绝对不能认为 &lt;code&gt;false&lt;/code&gt;从未返回。&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;name&lt;/h3&gt;

&lt;p&gt;返回代币的名字 ，例如 “MyToken”
可选 - 该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function name() view returns (string name)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;symbol&#34;&gt;symbol&lt;/h3&gt;

&lt;p&gt;返回代币的符号，例如“ETH”
可选 - 该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function symbol() view returns (string symbol)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;decimals&#34;&gt;decimals&lt;/h3&gt;

&lt;p&gt;返回代币的精确度，例如“8”，代币最小可以是0.00000001
可选 - 该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;totalsupply&#34;&gt;totalSupply&lt;/h3&gt;

&lt;p&gt;返回代币的总量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function totalSupply() view returns (uint256 totalSupply)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;balanceof&#34;&gt;balanceOf&lt;/h3&gt;

&lt;p&gt;返回地址为 _owner 账户的 账户余额&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function balanceOf(address _owner) view returns (uint256 balance)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;transfer&#34;&gt;transfer&lt;/h3&gt;

&lt;p&gt;将 &lt;code&gt;_value&lt;/code&gt; 数量的代币（从外面账户）转到账户 &lt;code&gt;_to&lt;/code&gt;,并且必须调用 &lt;code&gt;Transfer&lt;/code&gt; 事件。如果 &lt;code&gt;_from&lt;/code&gt; 账户余额不够使用的话，该函数 应该抛出 &lt;code&gt;throw&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function transfer(address _to, uint256 _value) returns (bool success)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;transferfrom&#34;&gt;transferFrom&lt;/h3&gt;

&lt;p&gt;实现代币用户之间的交易，将 &lt;code&gt;_value&lt;/code&gt; 数量的代币从 &lt;code&gt;_from&lt;/code&gt; 账户转账到 &lt;code&gt;_to&lt;/code&gt;账户，并且必须调用 &lt;code&gt;Transfer&lt;/code&gt; 事件。
transferFrom 方法用于退出工作流程，允许合约代表你来转账。例如，这可以允许合约代替你来交易或者收取子货币的费用。该函数应该抛出 &lt;code&gt;throw&lt;/code&gt;，除非 &lt;code&gt;_from&lt;/code&gt; 账户通过某些机制授权消息的发送者。
注意：交易数量为 0 的转账须当做正常交易，并且应该调用 &lt;code&gt;Transfer&lt;/code&gt;事件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function transferFrom(address _from, address _to, uint256 _value) returns (bool success)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;approve&#34;&gt;approve&lt;/h3&gt;

&lt;p&gt;该方法允许发送者&lt;code&gt;_spender&lt;/code&gt;从你的账户多次取走最多为&lt;code&gt;_value&lt;/code&gt;限额数量的代币。如果这个方法再次被调用，那么他会用&lt;code&gt;_value&lt;/code&gt;的值覆盖当前可用限额。
注意:为了避免攻击，客户端应该以这样的方式来设置限额，在设置其他值给同一个发送者之前，先设置成0（尽管为了向后兼容之前的合约，合约不会执行它）.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function approve(address _spender, uint256 _value) returns (bool success)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;allowance&#34;&gt;allowance&lt;/h3&gt;

&lt;p&gt;返回发送者&lt;code&gt;_spender&lt;/code&gt;还剩下可从&lt;code&gt;_owner&lt;/code&gt;取走的额度。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function allowance(address _owner, address _spender) view returns (uint256 remaining)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;事件&#34;&gt;事件&lt;/h2&gt;

&lt;h3 id=&#34;transfer-1&#34;&gt;Transfer&lt;/h3&gt;

&lt;p&gt;该事件必须在交易代币（Tokens）的时候出发，包括数量为0的交易。
当创建新代币时应该触发一个 &lt;code&gt;Transfer&lt;/code&gt;事件，并将_from账户设置为&lt;code&gt;0x0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;event Transfer(address indexed _from, address indexed _to, uint256 _value)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;approval&#34;&gt;Approval&lt;/h3&gt;

&lt;p&gt;该事件必须在 成功调用 &lt;code&gt;approve(address _spender, uint256 _value)&lt;/code&gt;的时候触发。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;event Approval(address indexed _owner, address indexed _spender, uint256 _value)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;

&lt;p&gt;现在已经有很多的兼容ERC20标准并且基于以太坊网络的代币。有众多的团队根据接口来实现了不一样的代币，这些不同的实现包括节约费用Gas，提高安全性。
以下是一些可用的实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol&#34;&gt;https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol&#34;&gt;https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个再次调用 &lt;code&gt;approve&lt;/code&gt;前，设置0操作的实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol&#34;&gt;https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Network Error Unable to load the page的解决办法</title>
      <link>https://www.3afun.com/post/2017/network-error-unable-to-load-the-page%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Fri, 15 Dec 2017 13:42:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/network-error-unable-to-load-the-page%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      
        <description>&lt;p&gt;Cocos2d-x加载一个http页面A，A中其中含有一个链接到https页面B。现在B页面返回到A页面报错Unable to load the page.Please keep network connection.&lt;/p&gt;

&lt;p&gt;尝试B页面加载Https页面C没问题，返回A有问题。&lt;/p&gt;

&lt;p&gt;修改办法是，B页面的href链接 采用如下形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a class=&amp;quot;class_name&amp;quot; href=&amp;quot;//www.example.com&amp;quot;&amp;gt;A Page&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Crontab 定时执行任务的环境变量问题</title>
      <link>https://www.3afun.com/post/2017/crontab-%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 20 Nov 2017 17:27:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/crontab-%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</guid>
      
        <description>&lt;p&gt;今天写了一个脚本文件，有用到Python3中time库的localtime函数。在单独执行该脚本文件时候，可以支持获取服务器date时间。但是放在Crontab里定时执行的时候，发现获取的是格林尼治时间。明明系统已经更改到北京时间，为什么还会显示格林尼治时间呢？
怀疑是crontab执行时和单独执行py脚本时候，系统环境变量不一致。&lt;/p&gt;

&lt;p&gt;最终原先直接在crontab里定时执行py脚本，改为定时执行shell文件，在shell文件里通过记载用户环境变量，再执行py文件，成功获取到北京时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>使用Charles 进行https抓包</title>
      <link>https://www.3afun.com/post/2017/%E4%BD%BF%E7%94%A8charles-%E8%BF%9B%E8%A1%8Chttps%E6%8A%93%E5%8C%85/</link>
      <pubDate>Sat, 18 Nov 2017 16:57:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/%E4%BD%BF%E7%94%A8charles-%E8%BF%9B%E8%A1%8Chttps%E6%8A%93%E5%8C%85/</guid>
      
        <description>

&lt;h1 id=&#34;1-charles安装&#34;&gt;1. Charles安装&lt;/h1&gt;

&lt;p&gt;官网下载安装Charles:
&lt;a href=&#34;https://www.charlesproxy.com/download/&#34;&gt;https://www.charlesproxy.com/download/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-http抓包&#34;&gt;2. HTTP抓包&lt;/h1&gt;

&lt;h2 id=&#34;1-查看电脑ip地址&#34;&gt;（1）查看电脑IP地址&lt;/h2&gt;

&lt;h2 id=&#34;2-设置手机http代理&#34;&gt;（2）设置手机HTTP代理&lt;/h2&gt;

&lt;p&gt;手机连上电脑，点击“设置-&amp;gt;无线局域网-&amp;gt;连接的WiFi”&lt;/p&gt;

&lt;p&gt;设置HTTP代理：服务器为电脑IP地址：如192.168.0.100 端口：8888&lt;/p&gt;

&lt;p&gt;设置代理后，需要在电脑上打开Charles才能上网&lt;/p&gt;

&lt;h2 id=&#34;3-电脑上打开charles进行http抓包&#34;&gt;（3）电脑上打开Charles进行HTTP抓包&lt;/h2&gt;

&lt;p&gt;手机上打开某个App&lt;/p&gt;

&lt;p&gt;点击电脑上“Allow”允许，出现手机的HTTP请求列&lt;/p&gt;

&lt;h1 id=&#34;3-https抓包&#34;&gt;3. HTTPS抓包&lt;/h1&gt;

&lt;p&gt;HTTPS的抓包需要在HTTP抓包基础上再进行设置&lt;/p&gt;

&lt;p&gt;手机浏览器打开 &lt;a href=&#34;https://chls.pro/ssl&#34;&gt;https://chls.pro/ssl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;并安装证书，记得要信任该证书。&lt;/p&gt;

&lt;p&gt;注意：IOS 版本10.3+的，还需要额外设置：&lt;/p&gt;

&lt;p&gt;设置-&amp;gt;通用-&amp;gt;关于本机-&amp;gt;证书信任设置-&amp;gt;Charles Proxy CA 证书那里打开。&lt;/p&gt;

&lt;p&gt;至此大家可以试下Https抓包效果了。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/&#34;&gt;https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Sass 安装 及其常见错误的解决办法</title>
      <link>https://www.3afun.com/post/2017/sass-%E5%AE%89%E8%A3%85-%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Wed, 27 Sep 2017 10:51:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/sass-%E5%AE%89%E8%A3%85-%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      
        <description>&lt;p&gt;Sass是一种css的开发工具，它的安装依赖Ruby，没有安装Ruby的请先安装Ruby。&lt;/p&gt;

&lt;p&gt;假定你已经安装了Ruby，则可以直接执行如下语句进行安装。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install sass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见错误提示：&lt;/p&gt;

&lt;p&gt;1、ERROR:  While executing gem &amp;hellip; (OpenSSL::SSL::SSLError)&lt;/p&gt;

&lt;p&gt;hostname &amp;ldquo;gems.ruby-china.org&amp;rdquo; does not match the server certificate&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;p&gt;执行命令，查看数据源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem source -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*** CURRENT SOURCES ***

https://ruby.taobao.org/
https://gems.ruby-china.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则可以删除多余的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem sources --remove https://ruby.taobao.org/
sudo gem update --system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重新安装。&lt;/p&gt;

&lt;p&gt;2、ERROR:  SSL verification error at depth 1: unable to get local issuer certificate (20)&lt;/p&gt;

&lt;p&gt;ERROR:  You must add /O=Digital Signature Trust Co./CN=DST Root CA X3 to your local trusted store&lt;/p&gt;

&lt;p&gt;Fetching: ffi-1.9.18.gem ( 32%)ERROR:  SSL verification error at depth 2: self signed certificate in certificate chain (19)&lt;/p&gt;

&lt;p&gt;ERROR:  Root certificate is not trusted (/C=US/O=GeoTrust Inc./CN=GeoTrust Global CA)&lt;/p&gt;

&lt;p&gt;ERROR:  While executing gem &amp;hellip; (OpenSSL::SSL::SSLError)&lt;/p&gt;

&lt;p&gt;hostname &amp;ldquo;gems.ruby-china.org&amp;rdquo; does not match the server certificate&lt;/p&gt;

&lt;p&gt;3、ERROR:  SSL verification error at depth 1: unable to get local issuer certificate (20)&lt;/p&gt;

&lt;p&gt;ERROR:  You must add /O=Digital Signature Trust Co./CN=DST Root CA X3 to your local trusted store&lt;/p&gt;

&lt;p&gt;Fetching: ffi-1.9.18.gem (100%)&lt;/p&gt;

&lt;p&gt;Building native extensions.  This could take a while&amp;hellip;&lt;/p&gt;

&lt;p&gt;Successfully installed ffi-1.9.18&lt;/p&gt;

&lt;p&gt;ERROR:  SSL verification error at depth 2: self signed certificate in certificate chain (19)&lt;/p&gt;

&lt;p&gt;ERROR:  Root certificate is not trusted (/C=US/O=GeoTrust Inc./CN=GeoTrust Global CA)&lt;/p&gt;

&lt;p&gt;Fetching: rb-inotify-0.9.10.gem (100%)&lt;/p&gt;

&lt;p&gt;Successfully installed rb-inotify-0.9.10&lt;/p&gt;

&lt;p&gt;Fetching: sass-listen-4.0.0.gem (100%)&lt;/p&gt;

&lt;p&gt;Successfully installed sass-listen-4.0.0&lt;/p&gt;

&lt;p&gt;Fetching: sass-3.5.1.gem (100%)&lt;/p&gt;

&lt;p&gt;ERROR:  While executing gem &amp;hellip; (Errno::EPERM)&lt;/p&gt;

&lt;p&gt;Operation not permitted - /usr/bin/sass&lt;/p&gt;

&lt;p&gt;遇到以上错误 2和3的解决办法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem install -n /usr/local/bin sass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sass -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则会正确显示Sass版本号。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2017年12月28日更新：&lt;/p&gt;

&lt;p&gt;Mac更新系统后，Ruby由2.0升级到2.3，再次使用Sass时候，发现报错。&lt;/p&gt;

&lt;p&gt;于是决定升级SaaS，重新安装时遇到错误。最后找到解决方案：&lt;/p&gt;

&lt;p&gt;先安装libgmp-dev，再重新安装即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install libgmp-dev
sudo gem install -n /usr/local/bin sass
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Tomcat8 多实例 Unix daemon 模式 </title>
      <link>https://www.3afun.com/post/2017/tomcat8-%E5%A4%9A%E5%AE%9E%E4%BE%8B-unix-daemon-%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 11 Sep 2017 18:47:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/tomcat8-%E5%A4%9A%E5%AE%9E%E4%BE%8B-unix-daemon-%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;h1 id=&#34;一-事前准备&#34;&gt;一、事前准备&lt;/h1&gt;

&lt;p&gt;Tomcat8（版本8.5.20） &lt;a href=&#34;http://apache.spinellicreations.com/tomcat/tomcat-8/v8.5.20/bin/apache-tomcat-8.5.20.tar.gz&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;JDK8（版本号1.8.0_144） &lt;a href=&#34;http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;二-配置部署&#34;&gt;二、配置部署&lt;/h1&gt;

&lt;h3 id=&#34;目录说明&#34;&gt;目录说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;jdk 安装目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;/usr/java/jdk1.8.0_144&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tomcat 安装目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;/usr/tomcat/apache-tomcat-8.5.20&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目代码目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;data/web/forum&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tomcat实例目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;/data/web/tomcat8_forum8082&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;tomcat安装&#34;&gt;tomcat安装&lt;/h3&gt;

&lt;p&gt;1.生成jsvc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/tomcat/apache-tomcat-8.5.20/bin
tar xvfz commons-daemon-native.tar.gz
cd commons-daemon-1.0.x-native-src/unix
./configure --with-java=/usr/java/jdk1.8.0_144
make
cp jsvc ../..
cd ../..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.复制tomcat 安装目录的conf 配置文件到实例目录conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/tomcat/apache-tomcat-8.5.20/conf /data/web/tomcat8_forum8082
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.修改相应端口号，此处使用8082.&lt;/p&gt;

&lt;p&gt;4.在/data/web/tomcat8_forum8082目录下新建启动脚本&lt;/p&gt;

&lt;p&gt;&lt;em&gt;startup.sh&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

JRE_HOME=&amp;quot;/usr/java/jdk1.8.0_144&amp;quot;
JAVA_HOME=&amp;quot;/usr/java/jdk1.8.0_144&amp;quot;
SERVER_PATH=&amp;quot;/data/web&amp;quot;
LOGS_PATH=&amp;quot;/data/web/logs/forum&amp;quot;
CATALINA_HOME=&amp;quot;/usr/tomcat/apache-tomcat-8.5.20&amp;quot;
CATALINA_BASE=&amp;quot;/data/web/tomcat8_forum8082&amp;quot;
CATALINA_PID=&amp;quot;$SERVER_PATH/tomcat8_forum8082/pid&amp;quot;
JAVA_OPTS=&amp;quot;-Xms512m -Xmx512m &amp;quot;
#TOMCAT_USER=&amp;quot;app100681811&amp;quot;

#export JAVA_HOME JRE_HOME LOGS_PATH CATALINA_HOME CATALINA_BASE
export JAVA_HOME JRE_HOME LOGS_PATH #CATALINA_HOME CATALINA_BASE CATALINA_PID
echo $&amp;quot;tomcat8_forum8082 start&amp;quot;
#/usr/tomcat/apache-tomcat-8.5.20/bin/catalina.sh start
export LANG=en_US.UTF-8

cd $CATALINA_HOME
./bin/jsvc \
    -classpath $CATALINA_HOME/bin/bootstrap.jar:$CATALINA_HOME/bin/tomcat-juli.jar \
    -outfile $CATALINA_BASE/logs/catalina.out \
    -errfile $CATALINA_BASE/logs/catalina.err \
    -pidfile &amp;quot;$CATALINA_PID&amp;quot; \
    -Dcatalina.home=$CATALINA_HOME \
    -Dcatalina.base=$CATALINA_BASE \
    -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager \
    -Djava.util.logging.config.file=$CATALINA_BASE/conf/logging.properties \
    org.apache.catalina.startup.Bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭脚本&lt;/p&gt;

&lt;p&gt;&lt;em&gt;shutdown.sh&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $&amp;quot;tomcat8_forum8082 stop&amp;quot;
ps aux | grep jsvc |grep &#39;/web/tomcat8_forum8082&#39;| grep -v &#39;grep&#39; | awk -F &#39; &#39; &#39;{print $2}&#39; | xargs kill -s 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.执行相应脚本，即可完成启动关闭。&lt;/p&gt;

&lt;h1 id=&#34;三-多实例模式&#34;&gt;三 、多实例模式&lt;/h1&gt;

&lt;p&gt;多实例模式，只需要复制tomcat实例目录，修改相应配置文件为B项目地址，端口号等信息即可。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>React入门 </title>
      <link>https://www.3afun.com/post/2017/react%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 20 Aug 2017 22:04:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/react%E5%85%A5%E9%97%A8/</guid>
      
        <description>

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;你可以进行一起全局安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo npm install -g create-react-app
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;创建一个应用&#34;&gt;创建一个应用&lt;/h1&gt;

&lt;p&gt;为了创建一个App，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create-react-app react_demo
cd react_demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完毕后，他会在当前目录下创建一个名为 react_demo 的文件夹。&lt;/p&gt;

&lt;p&gt;如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2017/react_01.png&#34; alt=&#34;react_01&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;运行&#34;&gt;运行&lt;/h1&gt;

&lt;p&gt;运行该App，可以执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd react_demo
npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开浏览器即可以看到自动初始化的界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2017/react_02.png&#34; alt=&#34;Areact_02&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python requirements.txt的使用</title>
      <link>https://www.3afun.com/post/2017/python-requirements.txt%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 16 Aug 2017 15:32:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/python-requirements.txt%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      
        <description>&lt;p&gt;在构建别人项目环境时，经常可以看到requirements.txt，这个文件记录了所依赖的包和版本。作用就是方便在另一台电脑搭建项目环境。那么如何使用呢？&lt;/p&gt;

&lt;p&gt;生成 &lt;em&gt;requirements.txt&lt;/em&gt; 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 &lt;em&gt;requirements.txt&lt;/em&gt; 依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>无法安裝COMPOSER 出現 COMMAND NOT FOUND 的解决办法</title>
      <link>https://www.3afun.com/post/2017/%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%9Dcomposer-%E5%87%BA%E7%8F%BE-command-not-found-%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Thu, 10 Aug 2017 11:32:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%9Dcomposer-%E5%87%BA%E7%8F%BE-command-not-found-%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      
        <description>&lt;p&gt;想要全局安装composer，按照网上的方法下载安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sS https://getcomposer.org/installer | php
mv composer.phar /usr/local/bin/composer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后检查结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;composer -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会出现，bash: composer: command not found Installation on Unixes (Ubuntu, Debian, CentOS, 等操作系统上)&lt;/p&gt;

&lt;p&gt;如果遇到了这个问题，那么可以将composer原先放在 &lt;em&gt;/usr/local/bin/&lt;/em&gt; 的路径，&lt;/p&gt;

&lt;p&gt;换成成以下目录 &lt;em&gt;/usr/bin/&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;解决办法的LINUX指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# sudo mv /usr/local/bin/composer /usr/bin/composer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着继续测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#composer -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会正确显示版本了~&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>nginx pid No such file or directory解决办法</title>
      <link>https://www.3afun.com/post/2017/nginx-pid-no-such-file-or-directory%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Wed, 14 Jun 2017 11:32:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/nginx-pid-no-such-file-or-directory%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      
        <description>&lt;p&gt;服务器重启后，有时会需要重新启动 nginx，采用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx -s reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx: [error] open() &amp;quot;/var/run/nginx.pid&amp;quot; failed (2: No such file or directory)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是因为服务器重启时丢了pid文件。&lt;/p&gt;

&lt;p&gt;这种情况下可以使用 nginx -c，具体如下（nginx.conf位置自行替换）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx -c /etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Python利用BeautifulSoup抓取解析网页数据</title>
      <link>https://www.3afun.com/post/2017/python%E5%88%A9%E7%94%A8beautifulsoup%E6%8A%93%E5%8F%96%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Wed, 10 May 2017 14:22:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/python%E5%88%A9%E7%94%A8beautifulsoup%E6%8A%93%E5%8F%96%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE/</guid>
      
        <description>&lt;p&gt;网页UI以及HTML组织形式，目的是抓取网页数据并解析。
&lt;img src=&#34;https://www.3afun.com/media/images/2017/python_01.png&#34; alt=&#34;UI&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;clan__table&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;clan__headers&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;clan__headerCaption&amp;quot;&amp;gt;Rank&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__headerCaption&amp;quot;&amp;gt;Name&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__headerCaption&amp;quot;&amp;gt;Level&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__headerCaption&amp;quot;&amp;gt;League&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__headerCaption&amp;quot;&amp;gt;Trophies&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__headerCaption&amp;quot;&amp;gt;Donations&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__headerCaption&amp;quot;&amp;gt;Role&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;


      &amp;lt;div class=&amp;quot;clan__rowContainer&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
                            #1
                    &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;a class=&amp;quot;ui__blueLink&amp;quot; href=&amp;quot;/profile/2P0V2CCY&amp;quot;&amp;gt;北斗&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;span class=&amp;quot;clan__playerLevel&amp;quot;&amp;gt;11&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;div class=&amp;quot;clan__leagueContainer&amp;quot;&amp;gt;
                            &amp;lt;div class=&amp;quot;league__2&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;div class=&amp;quot;clan__cup&amp;quot;&amp;gt;4438&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;379&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
             Leader
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;


      &amp;lt;div class=&amp;quot;clan__rowContainer&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
                            #2
                    &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;a class=&amp;quot;ui__blueLink&amp;quot; href=&amp;quot;/profile/9UURJRQU&amp;quot;&amp;gt;wglj&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;span class=&amp;quot;clan__playerLevel&amp;quot;&amp;gt;12&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;div class=&amp;quot;clan__leagueContainer&amp;quot;&amp;gt;
                            &amp;lt;div class=&amp;quot;league__2&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
           &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
          &amp;lt;div class=&amp;quot;clan__cup&amp;quot;&amp;gt;4344&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;498&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;clan__row&amp;quot;&amp;gt;
             Co-Leader
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;


&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2017/python_02.png&#34; alt=&#34;UI&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过查看页面源代码，我们发现每一个玩家信息都是存储在一个class为clan__rowContainer的div中。&lt;/p&gt;

&lt;p&gt;那么我们就可以通过soup的finaAll选择器来获取所有行的玩家信息，然后遍历挨个解析玩家数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i, row in enumerate(soup.findAll(&amp;quot;div&amp;quot;,attrs = {&amp;quot;class&amp;quot;:&amp;quot;clan__rowContainer&amp;quot;})):
        user_dict = {}
        for j,col in enumerate(row.findAll(&amp;quot;div&amp;quot;,attrs = {&amp;quot;class&amp;quot;:&amp;quot;clan__row&amp;quot;})):
            if j == 0:
                user_dict[&amp;quot;rank&amp;quot;] = col.string.strip().replace(&amp;quot;#&amp;quot;,&amp;quot;&amp;quot;)
            elif j == 1:
                user_dict[&amp;quot;name&amp;quot;] = col.a.string.strip()
                user_dict[&amp;quot;uid&amp;quot;] = col.a.get(&amp;quot;href&amp;quot;).strip(&amp;quot;/profile/&amp;quot;)
            elif j == 2:
                user_dict[&amp;quot;level&amp;quot;] = col.span.string.strip()
            elif j == 3:
                user_dict[&amp;quot;league&amp;quot;] = col.contents[1].div.get(&amp;quot;class&amp;quot;)[0].replace(&amp;quot;league__&amp;quot;,&amp;quot;&amp;quot;)
            elif j == 4:
                user_dict[&amp;quot;score&amp;quot;] = col.div.string.strip()
            elif j == 5:
                user_dict[&amp;quot;donations&amp;quot;] = col.string.strip()
            elif j == 6:
                user_dict[&amp;quot;role&amp;quot;] = col.string.strip()
        print(user_dict)
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>多版本Python下执行Twitter Ads API</title>
      <link>https://www.3afun.com/post/2017/%E5%A4%9A%E7%89%88%E6%9C%ACpython%E4%B8%8B%E6%89%A7%E8%A1%8Ctwitter-ads-api/</link>
      <pubDate>Wed, 29 Mar 2017 10:53:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/%E5%A4%9A%E7%89%88%E6%9C%ACpython%E4%B8%8B%E6%89%A7%E8%A1%8Ctwitter-ads-api/</guid>
      
        <description>&lt;p&gt;Twitter-API 地址&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/twitterdev/twitter-python-ads-sdk&#34;&gt;https://github.com/twitterdev/twitter-python-ads-sdk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mac电脑自带了Python2.7版本，Twitter在改版本下脚本是可执行的。但是我更想使用Python3，于是在电脑安装了Python3，然后再执行脚本发现缺少库。使用pip 安装后发现报已经安装过。最后就想应该是把待安装的库安装到Python3下。于是执行如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip3 install python-dateutil
pip3 install requests-oauthlib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再执行Quick Start 便可以获取到所创建的Campaigns&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from twitter_ads.client import Client
from twitter_ads.campaign import Campaign

CONSUMER_KEY = &#39;&#39;
CONSUMER_SECRET = &#39;
ACCESS_TOKEN = &#39;&#39;
ACCESS_TOKEN_SECRET = &#39;&#39;
ACCOUNT_ID = &#39;&#39;

# initialize the client
client = Client(CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN, ACCESS_TOKEN_SECRET)

# load the advertiser account instance
account = client.accounts(id=ACCOUNT_ID)


# iterate through campaigns
for campaign in account.campaigns():
    print(campaign.name)
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>CocosBuilder生成的ccbi文件与lua的交互</title>
      <link>https://www.3afun.com/post/2016/cocosbuilder%E7%94%9F%E6%88%90%E7%9A%84ccbi%E6%96%87%E4%BB%B6%E4%B8%8Elua%E7%9A%84%E4%BA%A4%E4%BA%92/</link>
      <pubDate>Fri, 02 Dec 2016 15:52:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2016/cocosbuilder%E7%94%9F%E6%88%90%E7%9A%84ccbi%E6%96%87%E4%BB%B6%E4%B8%8Elua%E7%9A%84%E4%BA%A4%E4%BA%92/</guid>
      
        <description>

&lt;h1 id=&#34;一-添加control-设置位置&#34;&gt;一、添加Control，设置位置。&lt;/h1&gt;

&lt;p&gt;属性设置如图所示
&lt;img src=&#34;https://www.3afun.com/media/images/2016/cocos.png&#34; alt=&#34;cocos builder ui&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;二-lua代码设置&#34;&gt;二、lua代码设置&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;-- 绑定
loginui[&amp;quot;close_btn&amp;quot;] = handler(self, self.onClose)


--响应事件
function AdLayer:onClose()
    ...
end
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
  </channel>
</rss>