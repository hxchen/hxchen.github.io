<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>我不是帅才</title>
    <link>https://www.3afun.com/</link>
    <description>Recent content on 我不是帅才</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright 3AFun</copyright>
    <lastBuildDate>Tue, 14 Feb 2012 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://www.3afun.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://www.3afun.com/about/</link>
      <pubDate>Tue, 14 Feb 2012 21:38:52 +0800</pubDate>
      
      <guid>https://www.3afun.com/about/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;个人介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;传说中的程序猿,混迹于互联网;&lt;/p&gt;

&lt;p&gt;写过Java、C++、NodeJs、Python、Android、Object-c等&lt;/p&gt;

&lt;p&gt;不限前端后端,可以说,工作需要什么,学什么,尽力做好产品。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;爱好&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;业余跑步,迄今为止,完成半程马拉松3次,全程马拉松3次。&lt;/p&gt;

&lt;p&gt;喜爱摄影、徒步,走过大半个中国,仅写过几篇&lt;a href=&#34;http://www.mafengwo.cn/u/5295523/note.html&#34; target=&#34;_blank&#34;&gt;游记&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Swift动态库FrameworkSDK开发</title>
      <link>https://www.3afun.com/post/2018/swift%E5%8A%A8%E6%80%81%E5%BA%93frameworksdk%E5%BC%80%E5%8F%91/</link>
      <pubDate>Fri, 18 May 2018 18:34:58 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/swift%E5%8A%A8%E6%80%81%E5%BA%93frameworksdk%E5%BC%80%E5%8F%91/</guid>
      
        <description>

&lt;p&gt;今天这篇文章主要是来讲解如何进行 &lt;code&gt;Cocoa Touch Framework&lt;/code&gt; 开发SDK,以及如何使用打包出来的SDK。&lt;/p&gt;

&lt;h2 id=&#34;学习目标&#34;&gt;学习目标&lt;/h2&gt;

&lt;p&gt;看完这篇文章,你将会学会:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用Xcode创建一个&lt;code&gt;Cocoa Touch Framework&lt;/code&gt;项目,进行SDK开发&lt;/li&gt;
&lt;li&gt;打包SDK&lt;/li&gt;
&lt;li&gt;使用storyboard进行简单布局&lt;/li&gt;
&lt;li&gt;UI和代码的链接,进行事件操作&lt;/li&gt;
&lt;li&gt;调用打包的SDK中的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;一-创建一个cocoa-touch-framework项目&#34;&gt;一、创建一个Cocoa Touch Framework项目&lt;/h2&gt;

&lt;h3 id=&#34;1-打开xcode-新建一个工程&#34;&gt;1.打开Xcode,新建一个工程&lt;/h3&gt;

&lt;p&gt;因为是进行Cocoa Touch Framework开发,所以我们要选择这个,然后点击next。
&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift01.png&#34; alt=&#34;new project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这里我们给我们的工程起个名字:AccountSDK
&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift02.png&#34; alt=&#34;new project&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-编写函数供sdk掉用者使用&#34;&gt;2.编写函数供SDK掉用者使用&lt;/h3&gt;

&lt;p&gt;菜单栏-&amp;gt;File-&amp;gt;New-&amp;gt;File&amp;hellip; 新建一个名为&lt;code&gt;LoginProcessor.swift&lt;/code&gt;的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift03.png&#34; alt=&#34;new file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LoginProcessor.swift&lt;/code&gt;代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation

public class LoginProcessor{

    public init(){

    }

    public func login(){
        NSLog(&amp;quot;LoginProcessor:login&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在类LoginProcessor里面我们先定义了构造函数init,然后定义了一个login函数供SDK调用者使用,功能非常简单,只是一句简单输出。&lt;/p&gt;

&lt;h3 id=&#34;3-打包sdk&#34;&gt;3.打包SDK&lt;/h3&gt;

&lt;p&gt;快捷键command+B打包SDK成framework文件,默认生产的文件会在Products目录下。我们可以选择文件,右键打开文件所在位置找到文件供接下来的步骤使用。
&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift04.png&#34; alt=&#34;findindir&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-创建single-view-app项目来测试sdk&#34;&gt;️二、创建Single View App项目来测试SDK&lt;/h2&gt;

&lt;h3 id=&#34;1-使用xcode新建一个名为accountsdkdemo的工程&#34;&gt;1.使用Xcode新建一个名为AccountSDKDemo的工程&lt;/h3&gt;

&lt;p&gt;Xcode菜单栏-&amp;gt;File-&amp;gt;New-&amp;gt;Project
&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift05.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift06.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-为storyboard添加button&#34;&gt;2.为storyboard添加Button&lt;/h3&gt;

&lt;p&gt;左侧导航栏选中&lt;code&gt;Main.storyboard&lt;/code&gt;,中间我们会看到一个UI,右侧有工具区。我们从工具区拖拽一个Button到中间编辑区的UI上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift07.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-切换到assistant-工作区&#34;&gt;3.切换到Assistant 工作区&lt;/h3&gt;

&lt;p&gt;点击工具栏左上角的 Show Assistant Editor&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift08.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-ui和代码的绑定&#34;&gt;4.UI和代码的绑定&lt;/h3&gt;

&lt;p&gt;1.编辑 ViewController.swift,在&lt;code&gt;UIViewController{&lt;/code&gt;下面添加注释 &lt;code&gt;//MARK: Properties&lt;/code&gt;,下面代码来绑定UI中的变量,
在类的最后一个括号上面添加一行注释&lt;code&gt;//MARK: Actions&lt;/code&gt;下面代码好绑定事件。&lt;/p&gt;

&lt;p&gt;2.在UI上选中Button按钮,右键拖拽一个Referencing Outlets到&lt;code&gt;//MARK: Properties&lt;/code&gt;下面,并起名&lt;code&gt;loginButton&lt;/code&gt;
拖拽一个Touch Up Inside事件到 &lt;code&gt;//MARK: Actions&lt;/code&gt;下面,起名&lt;code&gt;login&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift09.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-添加sdk&#34;&gt;5.添加SDK&lt;/h3&gt;

&lt;p&gt;1.复制步骤一中打包出来的SDK到AccountSDKDemo目录下,并添加。
&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift10.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.General-&amp;gt;Embedded Binaries中添加SDK。
&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift11.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-调用sdk代码&#34;&gt;6.调用SDK代码&lt;/h3&gt;

&lt;p&gt;编辑ViewController.swift,添加&lt;code&gt;import AccountSDK&lt;/code&gt;,并且在login事件中调用SDK中定义的login函数。
最终该文件应该是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;//
//  ViewController.swift
//  AccountSDKDemo
//
//  Created by 海祥陈 on 2018/5/18.
//  Copyright © 2018年 海祥陈. All rights reserved.
//

import UIKit
import AccountSDK

class ViewController: UIViewController {
    //MARK: Properties

    @IBOutlet weak var loginButton: UIButton!

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    //MARK: Actions

    // event for click login button
    @IBAction func login(_ sender: Any) {
        NSLog(&amp;quot;Login&amp;quot;);
        LoginProcessor().login();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-测试&#34;&gt;三、测试&lt;/h2&gt;

&lt;p&gt;Command+R 在模拟器上运行AccountSDKDemo App,运行后,点击Login按钮,观察后台日志,是否成功输出LoginProcessor中login函数的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/swift12.png&#34; alt=&#34;new Project&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Intellij Solidity智能合约开发插件</title>
      <link>https://www.3afun.com/post/2018/intellij-solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Wed, 25 Apr 2018 22:15:37 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/intellij-solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6/</guid>
      
        <description>&lt;p&gt;选择菜单栏Intellij IDEA -&amp;gt; Preferences -&amp;gt; Plugins -&amp;gt; Browse repositories, 然后搜索&lt;code&gt;Intellij-Solidity&lt;/code&gt;安装,重启Intellij IDEA即可生效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/plugins01.png&#34; alt=&#34;plugins&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/plugins02.png&#34; alt=&#34;plugins&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>智能合约和java智能包装的使用</title>
      <link>https://www.3afun.com/post/2018/working-with-smart-contracts-with-java-smart-contract-wrappers/</link>
      <pubDate>Wed, 25 Apr 2018 17:34:28 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/working-with-smart-contracts-with-java-smart-contract-wrappers/</guid>
      
        <description>

&lt;p&gt;本章节我们将学习如何从智能合约代码自动生成与java交换的java代码。&lt;/p&gt;

&lt;p&gt;首先我们需要安装Solidity编译器&lt;/p&gt;

&lt;h1 id=&#34;安装solidity编译器&#34;&gt;安装Solidity编译器&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo npm install -g solc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看是否安装成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;solcjs --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;安装web3j&#34;&gt;安装web3j&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew tap web3j/web3j
brew install web3j
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看web3j是否安装成功&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web3j
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;智能合约生成bin文件和abi文件&#34;&gt;智能合约生成bin文件和abi文件&lt;/h3&gt;

&lt;p&gt;现在我们有如下合约 CoolCoin.sol&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pragma solidity 0.4.23;
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
/**
 * owned 是一个管理者
 */
contract owned {
    address public owner;
    /**
     * 初台化构造函数
     */
    constructor() public {
        owner = msg.sender;
    }
    /**
     * 判断当前合约调用者是否是管理员
     */
    modifier onlyOwner {
        require (msg.sender == owner);
        _;
    }
    /**
     * 指派一个新的管理员
     * @param  newOwner address 新的管理员帐户地址
     */
    function transferOwnership(address newOwner) onlyOwner public{
        owner = newOwner;
    }
}
/**
 * @title 基础版的代币合约
 */
contract TokenERC20 {
    /* 公共变量 */
    string public name; //代币名称
    string public symbol; //代币符号比如&#39;$&#39;
    uint8 public decimals = 18;  //代币精度，展示的小数点后面多少个0,和以太币一样后面是是18个0
    uint256 public totalSupply; //代币总量
    /*记录所有余额的映射*/
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;
    /* 在区块链上创建一个事件，用以通知客户端*/
    event Transfer(address indexed from, address indexed to, uint256 value);  //转帐通知事件
    event Burn(address indexed from, uint256 value);  //减去用户余额事件
    /* 构造函数
     * 初始化合约，并且把初始的所有代币都给这合约的创建者
     * @param initialSupply 代币的总数
     * @param tokenName 代币名称
     * @param tokenSymbol 代币符号
     */
    constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public {
        //初始化总量
        totalSupply = initialSupply * 10 ** uint256(decimals);    //使用精度来更新总量
        //初始化总量赋值给创建者
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
    /**
     * 私有方法从一个帐户发送给另一个帐户代币，只能合约内部调用
     * @param  _from address 发送代币的地址
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function _transfer(address _from, address _to, uint256 _value) internal {
      //避免转帐的地址是0x0
      require(_to != 0x0);
      //检查发送者是否拥有足够余额
      require(balanceOf[_from] &amp;gt;= _value);
      //检查是否溢出
      require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);
      //保存数据用于后面的判断
      uint previousBalances = balanceOf[_from] + balanceOf[_to];
      //从发送者减掉发送额
      balanceOf[_from] -= _value;
      //给接收者加上相同的量
      balanceOf[_to] += _value;
      //通知任何监听该交易的客户端
      emit Transfer(_from, _to, _value);
      //判断买、卖双方的数据是否和转换前一致
      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    /**
     * 从主帐户合约调用者发送给别人代币
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
    /**
     * 从某个指定的帐户中，向另一个帐户发送代币
     *
     * 调用过程，会检查设置的允许最大交易额
     *
     * @param  _from address 发送者地址
     * @param  _to address 接受者地址
     * @param  _value uint256 要转移的代币数量
     * @return success        是否交易成功
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        //检查发送者是否拥有足够余额
        require(_value &amp;lt;= allowance[_from][msg.sender]);   // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    /**
     * 设置帐户允许支付的最大金额
     *
     * 一般在智能合约的时候，避免支付过多，造成风险
     *
     * @param _spender 帐户地址
     * @param _value 金额
     */
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
    /**
     * 设置帐户允许支付的最大金额
     *
     * 一般在智能合约的时候，避免支付过多，造成风险，加入时间参数，可以在 tokenRecipient 中做其他操作
     *
     * @param _spender 帐户地址
     * @param _value 金额
     * @param _extraData 操作的时间
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
    /**
     * 减少代币调用者的余额
     *
     * 操作以后是不可逆的
     *
     * @param _value 要删除的数量
     */
    function burn(uint256 _value) public returns (bool success) {
        //检查帐户余额是否大于要减去的值
        require(balanceOf[msg.sender] &amp;gt;= _value);   // Check if the sender has enough
        //给指定帐户减去余额
        balanceOf[msg.sender] -= _value;
        //代币问题做相应扣除
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    }
    /**
     * 删除帐户的余额（含其他帐户）
     *
     * 删除以后是不可逆的
     *
     * @param _from 要操作的帐户地址
     * @param _value 要减去的数量
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        //检查帐户余额是否大于要减去的值
        require(balanceOf[_from] &amp;gt;= _value);
        //检查 其他帐户 的余额是否够使用
        require(_value &amp;lt;= allowance[_from][msg.sender]);
        //减掉代币
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        //更新总量
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
}
/**
 * @title 高级版代币
 * 增加冻结用户、挖矿、根据指定汇率购买(售出)代币价格的功能
 */
contract MyAdvancedToken is owned, TokenERC20 {
    //卖出价格 单位是wei
    uint256 public sellPrice;
    //买入价格
    uint256 public buyPrice;
    //是否冻结帐户的列表
    mapping (address =&amp;gt; bool) public frozenAccount;
    //定义一个事件，当有资产被冻结的时候，通知正在监听事件的客户端
    event FrozenFunds(address target, bool frozen);
    /*初始化合约，并且把初始的所有的令牌都给这合约的创建者
     * @param initialSupply 所有币的总数
     * @param tokenName 代币名称
     * @param tokenSymbol 代币符号
     */
    constructor (uint256 initialSupply,string tokenName,string tokenSymbol) public TokenERC20 (initialSupply, tokenName, tokenSymbol){
     //初始化操作
     //   TokenERC20(_initialSupply, _tokenName, _tokenSymbol);
    }
    /**
     * 私有方法，从指定帐户转出余额
     * @param  _from address 发送代币的地址
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function _transfer(address _from, address _to, uint _value) internal {
        //避免转帐的地址是0x0
        require (_to != 0x0);
        //检查发送者是否拥有足够余额
        require (balanceOf[_from] &amp;gt;= _value);
        //检查是否溢出
        require (balanceOf[_to] + _value &amp;gt;= balanceOf[_to]);
        //检查 冻结帐户
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        //从发送者减掉发送额
        balanceOf[_from] -= _value;
        //给接收者加上相同的量
        balanceOf[_to] += _value;
        //通知任何监听该交易的客户端
        emit Transfer(_from, _to, _value);
    }
    /**
     * 合约拥有者，可以为指定帐户创造一些代币
     * @param  target address 帐户地址
     * @param  mintedAmount uint256 增加的金额(单位是wei)
     */
    function mintToken(address target, uint256 mintedAmount) onlyOwner public{
        //给指定地址增加代币，同时总量也相加
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(0, this, mintedAmount);
        emit Transfer(this, target, mintedAmount);
    }
    /**
     * 增加冻结帐户名称
     *
     * 你可能需要监管功能以便你能控制谁可以/谁不可以使用你创建的代币合约
     *
     * @param  target address 帐户地址
     * @param  freeze bool    是否冻结
     */
    function freezeAccount(address target, bool freeze) onlyOwner public{
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
    /**
     * 设置买卖价格
     *
     * 如果你想让ether(或其他代币)为你的代币进行背书,以便可以市场价自动化买卖代币,我们可以这么做。如果要使用浮动的价格，也可以在这里设置
     *
     * @param newSellPrice 新的卖出价格
     * @param newBuyPrice 新的买入价格
     */
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public{
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
    /**
     * 使用以太币购买代币,通过增加关键字 payable 我们就可以从任何账户接受以太币来调用这个函数。
     */
    function buy() payable public {
      uint amount = msg.value / buyPrice;
      _transfer(this, msg.sender, amount);
    }
    /**
     * @dev 卖出代币
     * @return 要卖出的数量(单位是wei)
     */
    function sell(uint256 amount) public {
        //检查合约的余额是否充足
        require(address(this).balance &amp;gt;= amount * sellPrice);
        _transfer(msg.sender, this, amount);
        msg.sender.transfer(amount * sellPrice);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在同位置新建一个build的目录来存储bin 和 abi 文件。然后用solc编译合约代码获得 bin 和 abi&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;solcjs CoolCoin.sol --bin --abi --optimize -o build/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用web3j编译bin和abi 获得包装代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web3j solidity generate /path/to/&amp;lt;smart-contract&amp;gt;.bin /path/to/&amp;lt;smart-contract&amp;gt;.abi -o /path/to/src/main/java -p com.your.organisation.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面从智能合约到生成java包装代码比较麻烦,更聪明的办法是你应该写一个脚本文件来处理:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash

set -e
set -o pipefail

targets=&amp;quot;
ens/ENS
ens/PublicResolver
&amp;quot;

for target in ${targets}; do
    dirName=$(dirname $target)
    fileName=$(basename $target)

    cd $dirName
    echo &amp;quot;Compiling Solidity file ${fileName}.sol:&amp;quot;
    solc --bin --abi --optimize --overwrite ${fileName}.sol -o build/
    echo &amp;quot;Complete&amp;quot;

    echo &amp;quot;Generating web3j bindings&amp;quot;
    web3j solidity generate \
        build/${fileName}.bin \
        build/${fileName}.abi \
        -p org.web3j.ens.contracts.generated \
        -o ../../../../main/java/ &amp;gt; /dev/null
    echo &amp;quot;Complete&amp;quot;

    cd -
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;讲解说明:&lt;/p&gt;

&lt;p&gt;该文件通过 targets 定义了 你要编译的合约ENS.sol和PublicResolver.sol&lt;/p&gt;

&lt;p&gt;然后遍历待编译的合约文件,通过solc命令来编译。&lt;/p&gt;

&lt;p&gt;最后通过web3j 命令来生成相应的java包装代码。&lt;/p&gt;

&lt;p&gt;参考:&lt;a href=&#34;https://github.com/web3j/web3j&#34; target=&#34;_blank&#34;&gt;web3j/web3j&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何同步一个fork</title>
      <link>https://www.3afun.com/post/2018/syncing-a-fork/</link>
      <pubDate>Tue, 24 Apr 2018 22:23:11 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/syncing-a-fork/</guid>
      
        <description>&lt;p&gt;有时我们fork一个项目到我们账号下,但是又想同步更新原先的内容,怎么办?别着急 &lt;strong&gt;remote upstream&lt;/strong&gt;可以来搞定。&lt;/p&gt;

&lt;p&gt;1.先使用&lt;code&gt;git remote -v&lt;/code&gt;查看远程状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote -v
origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.指定一个远程的 remote upstream 用以同步,也就是你fork而来的那个。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.确认新加的 upstream 库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote -v
origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.获取 upstream 的&lt;code&gt;master&lt;/code&gt;内容,该内容会被存在本地的 &lt;code&gt;upstream/master&lt;/code&gt;分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream
remote: Counting objects: 75, done.
remote: Compressing objects: 100% (53/53), done.
remote: Total 62 (delta 27), reused 44 (delta 9)
Unpacking objects: 100% (62/62), done.
From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY
 * [new branch]      master     -&amp;gt; upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.切换到本地&lt;code&gt;master&lt;/code&gt;分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout master
Switched to branch &#39;master&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.合并从&lt;code&gt;upstream/master&lt;/code&gt;来的变化到本地&lt;code&gt;master&lt;/code&gt;分支,这会将&lt;code&gt;fork&lt;/code&gt;的&lt;code&gt;master&lt;/code&gt;的内容同步到你本地,你本地也不会丢失内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git merge upstream/master
Updating a422352..5fdff0f
Fast-forward
 README                    |    9 -------
 README.md                 |    7 ++++++
 2 files changed, 7 insertions(+), 9 deletions(-)
 delete mode 100644 README
 create mode 100644 README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你本地没有改变的话,git会为你进行&amp;rdquo;fast-forward&amp;rdquo;合并&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git merge upstream/master
Updating 34e91da..16c56ad
Fast-forward
 README.md                 |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.如果你想更新到你的git上去,只要提交就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>远程调用以太坊智能合约</title>
      <link>https://www.3afun.com/post/2018/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</link>
      <pubDate>Sat, 21 Apr 2018 14:27:54 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</guid>
      
        <description>

&lt;p&gt;前面我们学习了部署以太坊合约,我们的操作都是在钱包中完成的。&lt;/p&gt;

&lt;p&gt;然而当我们面对我们的用户时我们不可能说叫他们安装钱包,然后学习这些复杂操作。&lt;/p&gt;

&lt;p&gt;对于普通的用户来说,这太不友好了,那么我们就得继续封装,允许用户在我们的网站或者手机上动动手指就可以完成简单的操作。&lt;/p&gt;

&lt;p&gt;下面我们就学习一下如何用代码的方式替代钱包里的操作来调用智能合约。&lt;/p&gt;

&lt;p&gt;我们重点讲一下两种访问智能合约方式: &lt;strong&gt;web3.js&lt;/strong&gt; 和 &lt;strong&gt;web3j&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;web3-js方式&#34;&gt;web3.js方式&lt;/h1&gt;

&lt;p&gt;如果你还没有安装node js 安装,请先安装node js,此处不再赘述。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;npm install web3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Web3 = require(&#39;web3&#39;);
web3 = new Web3(new Web3.providers.HttpProvider(&amp;quot;http://localhost:8545&amp;quot;));
var abi = [ { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;newSellPrice&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;newBuyPrice&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;setPrices&amp;quot;, &amp;quot;outputs&amp;quot;: [], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;name&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;CoolCoin&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;_spender&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;_value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;approve&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;success&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;totalSupply&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;1.009e+22&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;_from&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;_to&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;_value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;transferFrom&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;success&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;decimals&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint8&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;18&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;_value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;burn&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;success&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;sellPrice&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;1&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;balanceOf&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;0&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;target&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;mintedAmount&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;mintToken&amp;quot;, &amp;quot;outputs&amp;quot;: [], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;_from&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;_value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;burnFrom&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;success&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;buyPrice&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;2&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;owner&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;symbol&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;c&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [], &amp;quot;name&amp;quot;: &amp;quot;buy&amp;quot;, &amp;quot;outputs&amp;quot;: [], &amp;quot;payable&amp;quot;: true, &amp;quot;stateMutability&amp;quot;: &amp;quot;payable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;_to&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;_value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;transfer&amp;quot;, &amp;quot;outputs&amp;quot;: [], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;frozenAccount&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot;, &amp;quot;value&amp;quot;: false } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;_spender&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;_value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;_extraData&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bytes&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;approveAndCall&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;success&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: true, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;allowance&amp;quot;, &amp;quot;outputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;0&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;view&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;amount&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;sell&amp;quot;, &amp;quot;outputs&amp;quot;: [], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;target&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;freeze&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;freezeAccount&amp;quot;, &amp;quot;outputs&amp;quot;: [], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;constant&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;newOwner&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;transferOwnership&amp;quot;, &amp;quot;outputs&amp;quot;: [], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;function&amp;quot; }, { &amp;quot;inputs&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;initialSupply&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot;, &amp;quot;index&amp;quot;: 0, &amp;quot;typeShort&amp;quot;: &amp;quot;uint&amp;quot;, &amp;quot;bits&amp;quot;: &amp;quot;256&amp;quot;, &amp;quot;displayName&amp;quot;: &amp;quot;initial Supply&amp;quot;, &amp;quot;template&amp;quot;: &amp;quot;elements_input_uint&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;tokenName&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;index&amp;quot;: 1, &amp;quot;typeShort&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;bits&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;displayName&amp;quot;: &amp;quot;token Name&amp;quot;, &amp;quot;template&amp;quot;: &amp;quot;elements_input_string&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;&amp;quot; }, { &amp;quot;name&amp;quot;: &amp;quot;tokenSymbol&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;index&amp;quot;: 2, &amp;quot;typeShort&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;bits&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;displayName&amp;quot;: &amp;quot;token Symbol&amp;quot;, &amp;quot;template&amp;quot;: &amp;quot;elements_input_string&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;&amp;quot; } ], &amp;quot;payable&amp;quot;: false, &amp;quot;stateMutability&amp;quot;: &amp;quot;nonpayable&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;constructor&amp;quot; }, { &amp;quot;anonymous&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;indexed&amp;quot;: false, &amp;quot;name&amp;quot;: &amp;quot;target&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;indexed&amp;quot;: false, &amp;quot;name&amp;quot;: &amp;quot;frozen&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;bool&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;FrozenFunds&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;event&amp;quot; }, { &amp;quot;anonymous&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;indexed&amp;quot;: true, &amp;quot;name&amp;quot;: &amp;quot;from&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;indexed&amp;quot;: true, &amp;quot;name&amp;quot;: &amp;quot;to&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;indexed&amp;quot;: false, &amp;quot;name&amp;quot;: &amp;quot;value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;Transfer&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;event&amp;quot; }, { &amp;quot;anonymous&amp;quot;: false, &amp;quot;inputs&amp;quot;: [ { &amp;quot;indexed&amp;quot;: true, &amp;quot;name&amp;quot;: &amp;quot;from&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;address&amp;quot; }, { &amp;quot;indexed&amp;quot;: false, &amp;quot;name&amp;quot;: &amp;quot;value&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;uint256&amp;quot; } ], &amp;quot;name&amp;quot;: &amp;quot;Burn&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;event&amp;quot; } ];
var address = &amp;quot;0x63b5047Decd4501d4eb3bb7b30e3da89cE37c2f5&amp;quot;;
var coolcoin = new web3.eth.Contract(abi);
coolcoin.options.address = address;
coolcoin.methods.balanceOf(&#39;0xc2298C3398584aaB380fafb564037D9Fb910e0a1&#39;).call({from: address}, function(error, result){
    console.log(result);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;代码讲解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第1行代码我们引入了web3的库。&lt;/p&gt;

&lt;p&gt;第2行代码设置服务器。&lt;/p&gt;

&lt;p&gt;第3行代码设置ABI（Application Binary Interface）: 应用程序二进制接口。这里的ABI我们可以在钱包界面,点击显示界面,复制其中的JSon格式数据即可。
里面主要订了我们合约内容。&lt;/p&gt;

&lt;p&gt;第4行填写合约地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/rpc01.png&#34; alt=&#34;rpc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第5、6行通过abi和address获取合约。&lt;/p&gt;

&lt;p&gt;最后我们以异步方式调用&lt;code&gt;balanceOf&lt;/code&gt;方法,该方法使用了address来查询地址&lt;code&gt;0xc2298C3398584aaB380fafb564037D9Fb910e0a1&lt;/code&gt;有多少个Cool Coin。&lt;/p&gt;

&lt;p&gt;大家可以通过执行该方法对比Mist钱包查询,自行验证余额是否一致。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node CoolCoin.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关 web3 更多 API可参考 :
&lt;a href=&#34;https://web3js.readthedocs.io/en/1.0/getting-started.html&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;web3j方式&#34;&gt;web3j方式&lt;/h1&gt;

&lt;h2 id=&#34;合约准备&#34;&gt;合约准备:&lt;/h2&gt;

&lt;p&gt;由于java的远程调用合约需要一个编译后的二进制码,利用已经存在的合约时,我暂未找到如何获取这个二进制码,所以在此我又重新发布了一个新合约才能获取编译后的二进制码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/rpc02.png&#34; alt=&#34;rpc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/rpc03.png&#34; alt=&#34;rpc&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;

&lt;h3 id=&#34;maven&#34;&gt;Maven&lt;/h3&gt;

&lt;p&gt;java 8:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.web3j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CoolCoin.java&lt;/p&gt;

&lt;p&gt;继承自Contract 并且对合约进行封装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;
import org.web3j.crypto.Credentials;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.RemoteCall;
import org.web3j.tx.Contract;

import java.math.BigInteger;
import java.util.Arrays;

/**
 * Created by hxchen on 2018/4/21.
 */
public class CoolCoin extends Contract{
    private static final String BINARY = &amp;quot;0x60606040526003805460ff19166012179055341561001c57600080fd5b604051610e32380380610e32833981016040528080519190602001805182019190602001805160008054600160a060020a033316600160a060020a03199091168117825560035460ff16600a0a870260048190559082526005602052604090912055909101905082828260018280516100999291602001906100b9565b5060028180516100ad9291602001906100b9565b50505050505050610154565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100fa57805160ff1916838001178555610127565b82800160010185558215610127579182015b8281111561012757825182559160200191906001019061010c565b50610133929150610137565b5090565b61015191905b80821115610133576000815560010161013d565b90565b610ccf806101636000396000f3006060604052600436106101275763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166305fefda7811461012c57806306fdde0314610147578063095ea7b3146101d157806318160ddd1461020757806323b872dd1461022c578063313ce5671461025457806342966c681461027d5780634b7503341461029357806370a08231146102a657806379c65068146102c557806379cc6790146102e75780638620410b146103095780638da5cb5b1461031c57806395d89b411461034b578063a6f2ae3a1461035e578063a9059cbb14610366578063b414d4b614610388578063cae9ca51146103a7578063dd62ed3e1461040c578063e4849b3214610431578063e724529c14610447578063f2fde38b1461046b575b600080fd5b341561013757600080fd5b61014560043560243561048a565b005b341561015257600080fd5b61015a6104b0565b60405160208082528190810183818151815260200191508051906020019080838360005b8381101561019657808201518382015260200161017e565b50505050905090810190601f1680156101c35780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34156101dc57600080fd5b6101f3600160a060020a036004351660243561054e565b604051901515815260200160405180910390f35b341561021257600080fd5b61021a61057e565b60405190815260200160405180910390f35b341561023757600080fd5b6101f3600160a060020a0360043581169060243516604435610584565b341561025f57600080fd5b6102676105fb565b60405160ff909116815260200160405180910390f35b341561028857600080fd5b6101f3600435610604565b341561029e57600080fd5b61021a61068f565b34156102b157600080fd5b61021a600160a060020a0360043516610695565b34156102d057600080fd5b610145600160a060020a03600435166024356106a7565b34156102f257600080fd5b6101f3600160a060020a036004351660243561076d565b341561031457600080fd5b61021a610849565b341561032757600080fd5b61032f61084f565b604051600160a060020a03909116815260200160405180910390f35b341561035657600080fd5b61015a61085e565b6101456108c9565b341561037157600080fd5b610145600160a060020a03600435166024356108e9565b341561039357600080fd5b6101f3600160a060020a03600435166108f8565b34156103b257600080fd5b6101f360048035600160a060020a03169060248035919060649060443590810190830135806020601f8201819004810201604051908101604052818152929190602084018383808284375094965061090d95505050505050565b341561041757600080fd5b61021a600160a060020a0360043581169060243516610a3b565b341561043c57600080fd5b610145600435610a58565b341561045257600080fd5b610145600160a060020a03600435166024351515610ab5565b341561047657600080fd5b610145600160a060020a0360043516610b41565b60005433600160a060020a039081169116146104a557600080fd5b600791909155600855565b60018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105465780601f1061051b57610100808354040283529160200191610546565b820191906000526020600020905b81548152906001019060200180831161052957829003601f168201915b505050505081565b600160a060020a033381166000908152600660209081526040808320938616835292905220819055600192915050565b60045481565b600160a060020a038084166000908152600660209081526040808320339094168352929052908120548211156105b957600080fd5b600160a060020a03808516600090815260066020908152604080832033909416835292905220805483900390556105f1848484610b8b565b5060019392505050565b60035460ff1681565b600160a060020a0333166000908152600560205260408120548290101561062a57600080fd5b600160a060020a03331660008181526005602052604090819020805485900390556004805485900390557fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca59084905190815260200160405180910390a2506001919050565b60075481565b60056020526000908152604090205481565b60005433600160a060020a039081169116146106c257600080fd5b600160a060020a03808316600090815260056020526040808220805485019055600480548501905530909216917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9084905190815260200160405180910390a381600160a060020a031630600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405190815260200160405180910390a35050565b600160a060020a0382166000908152600560205260408120548290101561079357600080fd5b600160a060020a03808416600090815260066020908152604080832033909416835292905220548211156107c657600080fd5b600160a060020a038084166000818152600560209081526040808320805488900390556006825280832033909516835293905282902080548590039055600480548590039055907fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca59084905190815260200160405180910390a250600192915050565b60085481565b600054600160a060020a031681565b60028054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105465780601f1061051b57610100808354040283529160200191610546565b6000600854348115156108d857fe5b0490506108e6303383610b8b565b50565b6108f4338383610b8b565b5050565b60096020526000908152604090205460ff1681565b60008361091a818561054e565b15610a335780600160a060020a0316638f4ffcb1338630876040518563ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018085600160a060020a0316600160a060020a0316815260200184815260200183600160a060020a0316600160a060020a0316815260200180602001828103825283818151815260200191508051906020019080838360005b838110156109d05780820151838201526020016109b8565b50505050905090810190601f1680156109fd5780820380516001836020036101000a031916815260200191505b5095505050505050600060405180830381600087803b1515610a1e57600080fd5b5af11515610a2b57600080fd5b505050600191505b509392505050565b600660209081526000928352604080842090915290825290205481565b6007548102600160a060020a033016311015610a7357600080fd5b610a7e333083610b8b565b33600160a060020a03166108fc60075483029081150290604051600060405180830381858888f1935050505015156108e657600080fd5b60005433600160a060020a03908116911614610ad057600080fd5b600160a060020a03821660009081526009602052604090819020805460ff19168315151790557f48335238b4855f35377ed80f164e8c6f3c366e54ac00b96a6402d4a9814a03a5908390839051600160a060020a039092168252151560208201526040908101905180910390a15050565b60005433600160a060020a03908116911614610b5c57600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600160a060020a0382161515610ba057600080fd5b600160a060020a03831660009081526005602052604090205481901015610bc657600080fd5b600160a060020a0382166000908152600560205260409020548181011015610bed57600080fd5b600160a060020a03831660009081526009602052604090205460ff1615610c1357600080fd5b600160a060020a03821660009081526009602052604090205460ff1615610c3957600080fd5b600160a060020a038084166000818152600560205260408082208054869003905592851680825290839020805485019055917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9084905190815260200160405180910390a35050505600a165627a7a72305820628d037ae8221aa68e448d70bb5fe7f7d05e02ada2a2d90239f76813723a6629002900000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000009436f6f6c436f696e32000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012400000000000000000000000000000000000000000000000000000000000000&amp;quot;;

    /**
     * 构造函数
     * @param contractAddress
     * @param web3j
     * @param credentials
     * @param gasPrice
     * @param gasLimit
     */
    public CoolCoin(String contractAddress, Web3j web3j, Credentials credentials, BigInteger gasPrice, BigInteger gasLimit){
        super(BINARY, contractAddress, web3j, credentials, gasPrice, gasLimit);
    }

    /**
     * 加载合约
     * @param contractAddress
     * @param web3j
     * @param credentials
     * @param gasPrice
     * @param gasLimit
     * @return
     */
    public static CoolCoin load(String contractAddress, Web3j web3j, Credentials credentials, BigInteger gasPrice, BigInteger gasLimit) {
        return new CoolCoin(contractAddress, web3j, credentials, gasPrice, gasLimit);
    }

    /**
     * 调用合约函数 balanceOf
     * @param address
     * @return
     */
    public RemoteCall balanceOf(String address){
        Function function = new Function(&amp;quot;balanceOf&amp;quot;,
                Arrays.&amp;lt;Type&amp;gt;asList(new org.web3j.abi.datatypes.Address(address)),
                Arrays.&amp;lt;TypeReference&amp;lt;?&amp;gt;&amp;gt;asList(new TypeReference&amp;lt;Uint256&amp;gt;() {}));
        return executeRemoteCallSingleValueReturn(function, BigInteger.class);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CoolCoinClient.java&lt;/p&gt;

&lt;p&gt;一个调用合约函数的测试文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import com.threeafun.ethereum.contract.CoolCoin;
import org.web3j.crypto.Credentials;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.RemoteCall;
import org.web3j.protocol.http.HttpService;
import org.web3j.tx.Contract;


/**
 * Created by hxchen on 2018/4/21.
 */
public class CoolCoinClient{

    public static void main( String[] args ) throws Exception
    {
        Web3j web3j = Web3j.build(new HttpService(&amp;quot;http://localhost:8545&amp;quot;));
        try {

            String account = web3j.ethAccounts().send().getAccounts().get(0);
            Credentials credentials = Credentials.create(account);
            //合约地址
            String address=&amp;quot;0xd69A0599df3C0dd9ACAa0a9E47365730E9f4ee99&amp;quot;;
            CoolCoin coolCoin = CoolCoin.load(address,web3j,credentials, Contract.GAS_PRICE,Contract.Contract.GAS_LIMIT);
            //待查询余额的账户地址
            String account2 = &amp;quot;0xc2298C3398584aaB380fafb564037D9Fb910e0a1&amp;quot;;
            RemoteCall remoteCall= coolCoin.balanceOf(account);
            System.out.println(&amp;quot;返回结果:&amp;quot;+remoteCall.send());
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关 web3j 更多可参考:&lt;a href=&#34;https://github.com/web3j/web3j&#34; target=&#34;_blank&#34;&gt;web3j&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;全文涉及到的代码, 在&lt;a href=&#34;https://github.com/hxchen/web3&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>以太坊钱包删除合约</title>
      <link>https://www.3afun.com/post/2018/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E5%88%A0%E9%99%A4%E5%90%88%E7%BA%A6/</link>
      <pubDate>Wed, 18 Apr 2018 18:13:20 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E5%88%A0%E9%99%A4%E5%90%88%E7%BA%A6/</guid>
      
        <description>&lt;p&gt;以太坊钱包想删除不用的合约怎么办?&lt;/p&gt;

&lt;p&gt;1.菜单栏——&amp;gt;&amp;gt;开发——&amp;gt;&amp;gt;切换开发者工具——&amp;gt;&amp;gt;Ethereum Wallet,打开控制台。&lt;/p&gt;

&lt;p&gt;2.获取合约 &lt;strong&gt;_id&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CustomContracts.find().fetch()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.根据ID删除合约&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CustomContracts.remove(&#39;_id&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/mist01.png&#34; alt=&#34;mist01&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何利用私有链来创建自己的加密代币</title>
      <link>https://www.3afun.com/post/2018/how-to-use-your-own-private-ethereum-blockchain-to-create-your-own-crypto-currency/</link>
      <pubDate>Mon, 16 Apr 2018 11:24:49 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/how-to-use-your-own-private-ethereum-blockchain-to-create-your-own-crypto-currency/</guid>
      
        <description>

&lt;p&gt;根据前面的几篇文章,我们已经可以创建自己的私有链、使用钱包来链接私有链,今天我们来学习如何使用私有链来创建我们自己的加密货币。&lt;/p&gt;

&lt;h1 id=&#34;工具&#34;&gt;工具&lt;/h1&gt;

&lt;p&gt;1.私有链服务器 Geth Server&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE1/&#34;&gt;Ubuntu16.04 搭建以太坊Ethereum私链1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE2/&#34;&gt;Ubuntu16.04 搭建以太坊Ethereum私链2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.客户端钱包 Mist&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.3afun.com/post/2018/ethereum-wallet%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E9%93%BE%E6%8E%A5geth-server%E7%A7%81%E6%9C%89%E9%93%BE/&#34;&gt;Ethereum wallet以太坊钱包链接Geth Server私有链&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;最低限度的代币-minimum-viable-token&#34;&gt;最低限度的代币(Minimum Viable Token)&lt;/h1&gt;

&lt;p&gt;标准代币合约可以非常的复杂,但是一个基本的代币像如下这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pragma solidity ^0.4.20;

contract MyToken {
    /* This creates an array with all balances */
    mapping (address =&amp;gt; uint256) public balanceOf;

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken(
        uint256 initialSupply
        ) public {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
    }

    /* Send coins */
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] &amp;gt;= _value);           // Check if the sender has enough
        require(balanceOf[_to] + _value &amp;gt;= balanceOf[_to]); // Check for overflows
        balanceOf[msg.sender] -= _value;                    // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;基础版代币-the-code&#34;&gt;基础版代币 The Code&lt;/h1&gt;

&lt;p&gt;如果你只想复制粘贴来实现一个完整的代币,可以使用下面这个。这个是ERC20 规范的代币合约 。相应的标准可以参考之前文章
&lt;a href=&#34;https://www.3afun.com/post/2018/erc-20-token-standard/&#34;&gt;ERC20 标准规范&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pragma solidity ^0.4.16;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constructor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] &amp;gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &amp;gt;= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &amp;lt;= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &amp;gt;= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] &amp;gt;= _value);                // Check if the targeted balance is enough
        require(_value &amp;lt;= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;如何发布-how-to-deploy&#34;&gt;如何发布 How to deploy&lt;/h1&gt;

&lt;p&gt;1.点击钱包右上角合约,选择部署新合约
&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy01.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.将上面代码复制粘贴到左边Solidity合约原始代码,右边选择合约Token ERC20 填写相应初始量、代币名称、代币符号后点击最下面 部署按钮&lt;/p&gt;

&lt;p&gt;在这里我们发行量选择 1,000,000枚 起名字 BBCoin 货币符号 BBC
&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy02.png&#34; alt=&#34;deploy step&#34; /&gt;
输入密码后,回到合约界面等待一会即可看到自己发布的代币
&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy03.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy04.png&#34; alt=&#34;deploy step&#34; /&gt;
3.回到钱包主界面,点击选择我们的主账户,我们可以看到我们的账户里已经有我们发行的货币了
&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy05.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy06.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;转账&#34;&gt;转账&lt;/h1&gt;

&lt;p&gt;1.通过钱包转账&lt;/p&gt;

&lt;p&gt;点击发送,选择发送资金时候可以选择我们刚刚创建的BBCoin就可以了
&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy07.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们点击钱包,去查看账户2的内容,就可以看到多了相应数量的BBCoin
&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy08.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.通过合约转账&lt;/p&gt;

&lt;p&gt;进入合约管理界面,选择相应的函数,填写参数,执行就好。&lt;/p&gt;

&lt;p&gt;(注意:上面我们定义的精度是18,这里参数也是需要带精度的)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy09.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy10.png&#34; alt=&#34;deploy step&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;提升你代币&#34;&gt;提升你代币&lt;/h1&gt;

&lt;h2 id=&#34;其他更多基础函数&#34;&gt;其他更多基础函数&lt;/h2&gt;

&lt;p&gt;在上面基础版代码中,你可能注意到还有一些其他基本的函数,像是&lt;code&gt;approve&lt;/code&gt;,&lt;code&gt;sendFrom&lt;/code&gt;等。这些函数是用来和其他合约进行交互用。
假如你需要出售你的代币到一个去中心化交易,只发送代币到一个地址是不够的,因为合约不会订阅 Events, 只会进行 functions call,所以这次的交换不会被识别成新的代币,不知道是谁发送的。
所以对于合约,你需要首先批准一定量的他们可以从你账户进行转移的代币,然后才能告诉他们让他们知道应该做一些事,或者你可以使用&lt;code&gt;approveAndCall&lt;/code&gt;可以把这2个操作合二为一。&lt;/p&gt;

&lt;p&gt;因为很多这些函数需要重新实现代币转账,所以将他们定义成内部函数是有意义的,像是下面的只可以由合约自身来调用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /* Internal transfer, can only be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] &amp;gt;= _value);                // Check if the sender has enough
        require (balanceOf[_to] + _value &amp;gt;= balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在所有可以转移代币的函数都可以执行自己的检查,然后再使用正确的参数来调用 transfer函数。我们会发现这个函数会从一个账户转移到另一个账户,而不需要一个人的允许。所以我们要将他定义成一个内部函数,只能被合约来调用。如果你想增加可以调用这个函数的函数,你需要检查调用者是否有权来调用。&lt;/p&gt;

&lt;h2 id=&#34;中心化管理员&#34;&gt;中心化管理员&lt;/h2&gt;

&lt;p&gt;所有的Dapps默认是完全去中心化的,这并不意味着他们不需要一些中心化的管理者。或许你需要有货币增发的功能,或者你需要禁止某些人使用你的代币。
你可以添加诸如此类的一些功能,唯一需要做的就是在一开始的时候添加这些功能,所以那些代币持有者永远会在他们决定持有前确切的知道游戏规则。&lt;/p&gt;

&lt;p&gt;期待这些事可以实现,你需要一个中心货币管理者。这可以是一个简单的账户,但也可以是一个合约,因此创建更多代币的决定取决于合约:如果他是一个可以投票的民主组织或者它只是一个限制代币所有者的权力。&lt;/p&gt;

&lt;p&gt;为了做到这些,我们会学习到一个非常有用的合约属性: &lt;code&gt;inheritance&lt;/code&gt;。继承允许一个合约无需重新定义他们就得到父合约的一些特点。这就可以使代码干净,简单可复用。在你的代码&lt;code&gt;contract MyToken {&lt;/code&gt;前面,先添加添加如下代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;contract owned {
        address public owner;

        function owned() {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }

        function transferOwnership(address newOwner) onlyOwner {
            owner = newOwner;
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这创建了一个非常简单的合约,你不需要做什么,只需要在名为&lt;code&gt;owned&lt;/code&gt;里面定义有关合约的一些通用的函数。
下一步就是只需要在你合约里面添加  &lt;code&gt;is owned&lt;/code&gt;即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    contract MyToken is owned {
        /* the rest of the contract as usual */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这意味着你在&lt;code&gt;MyToken&lt;/code&gt;里面所有的函数都可要访问&lt;code&gt;owner&lt;/code&gt;变量和修改者&lt;code&gt;onlyOwner&lt;/code&gt;。这个合约同事也得到了一个可以转换管理员的函数。
因为在开始的时候设置一个管理者会非常的有趣,所以你可以把这个功能添加到构造函数中去:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol,
        address centralMinter
        ) {
        if(centralMinter != 0 ) owner = centralMinter;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代币增发&#34;&gt;代币增发&lt;/h2&gt;

&lt;p&gt;有时我们可能需要货币增发或者删除的情况。&lt;/p&gt;

&lt;p&gt;我们首先需要增加一个&lt;code&gt;totalSupply&lt;/code&gt;变量来存储发行量,并且在构造函数中指定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    contract MyToken {
        uint256 public totalSupply;

        function MyToken(...) {
            totalSupply = initialSupply;
            ...
        }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们来增加一个函数,可以让管理员来发行新币&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到上面的修饰符&lt;code&gt;onlyOwner&lt;/code&gt;说明 &lt;code&gt;mintToken&lt;/code&gt; 是继承了 &lt;code&gt;onlyOwner&lt;/code&gt;方法，会先调用 &lt;code&gt;modifier onlyOwner&lt;/code&gt; 方法，然后将&lt;code&gt;mintToken&lt;/code&gt; 方法的内容，插入到下划线 &lt;code&gt;_&lt;/code&gt; 处调用。&lt;/p&gt;

&lt;h2 id=&#34;冻结资产&#34;&gt;冻结资产&lt;/h2&gt;

&lt;p&gt;根据你的适用情况,你可能会需要一些监管来让谁或者禁止谁来使用你的代币,你需要添加一个参数来让合约管理员冻结或者解冻资产。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mapping (address =&amp;gt; bool) public frozenAccount;
    event FrozenFunds(address target, bool frozen);

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这段代码,所有的账户默认是非冻结状态,管理员可以通过调用&lt;code&gt;Freeze Account&lt;/code&gt;来冻结账户。但是到目前还没有正式生效,我们还需在转账交易函数里添加如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function transfer(address _to, uint256 _value) {
        require(!frozenAccount[msg.sender]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在被冻结账户仍然玩好的拥有资金,但是不能转移他们。所有的账户默认是非冻结状态,除非你去冻结他们,但是你可以轻易的还原这个行为,把他们一个个的手动批准加入到白名单中去。
只需要把&lt;code&gt;frozenAccount&lt;/code&gt;重命名成&lt;code&gt;approvedAccount&lt;/code&gt;并且把最后一行代码改成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    require(approvedAccount[msg.sender]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自动买卖&#34;&gt;自动买卖&lt;/h2&gt;

&lt;p&gt;到目前为止,你依靠效用和信任来评估你的代币。但是你如果想要的话,你可以通过创建一个基金来以市场价进行买卖兑换以太币或者其他代币。&lt;/p&gt;

&lt;p&gt;首先让我们来设置一个买入和卖出价格:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于一个不经常变的价格,这是可以接受的。因为每次更改价格将会需要你来执行一个合同并且花费一点的以太币。如果你希望有个持续浮动的价格,我们建议你研究一下 &lt;a href=&#34;https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs#data-feeds&#34;&gt;standard data feeds&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下一步来增加购买和销售函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function buy() payable returns (uint amount){
        amount = msg.value / buyPrice;                    // calculates the amount
        require(balanceOf[this] &amp;gt;= amount);               // checks if it has enough to sell
        balanceOf[msg.sender] += amount;                  // adds the amount to buyer&#39;s balance
        balanceOf[this] -= amount;                        // subtracts amount from seller&#39;s balance
        Transfer(this, msg.sender, amount);               // execute an event reflecting the change
        return amount;                                    // ends function and returns
    }

    function sell(uint amount) returns (uint revenue){
        require(balanceOf[msg.sender] &amp;gt;= amount);         // checks if the sender has enough to sell
        balanceOf[this] += amount;                        // adds the amount to owner&#39;s balance
        balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller&#39;s balance
        revenue = amount * sellPrice;
        msg.sender.transfer(revenue);                     // sends ether to the seller: it&#39;s important to do this last to prevent recursion attacks
        Transfer(msg.sender, this, amount);               // executes an event reflecting on the change
        return revenue;                                   // ends function and returns
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buy函数中我们增加了一个payable关键字,表示调用者可以直接向该函数传入以太币进行调用。&lt;/p&gt;

&lt;p&gt;注意:买入和卖出价格并不是以Ether为单位,而是以wei(最小货币精度)为单位。1Ether = 1000000000000000000 wei。所以当在Ether中设置价格时,后面需要加18个0.&lt;/p&gt;

&lt;p&gt;不明白的话,可以看后面的Sell Buy 测试数据。&lt;/p&gt;

&lt;p&gt;当创建合约时,要发送足够的Ether以确保能买回来市场上所有的代币,否则你的合约会破产并且你的用户不能卖出他们的代币。&lt;/p&gt;

&lt;p&gt;前面的例子,当然是在描述一个和单个中央卖方买方的合约,更有趣的合约是允许任何人都可要设置不懂竞价的市场,或者直接从外部来源加载价格。&lt;/p&gt;

&lt;h2 id=&#34;自动补充&#34;&gt;自动补充&lt;/h2&gt;

&lt;p&gt;每一次你想在以太坊上进行一笔交易,你需要支付一些费用给挖这个区块的矿工以计算你合约的结果。 &lt;a href=&#34;https://github.com/ethereum/EIPs/issues/28&#34;&gt;未来这可能会改变&lt;/a&gt;
目前费用只能用以太币来支付因此你代币的用户都需要它。
账户余额小于特定费用的时候会被卡住,直到所有人owner可以支付所需费用。但是在有些情况下,你或许不希望你的用户来考虑以太币,区块链或者怎么获取以太币,所以一个可以的办法是让你的币只要检测余额低的有些危险的时候可以自动补充。&lt;/p&gt;

&lt;p&gt;为了做到这样,首先你需要创建一个变量来保存阈值和一个函数来改变它。如果你不知道应该设置多少,设置&lt;strong&gt;5finney&lt;/strong&gt;(0.005以太币)就好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    uint public minBalanceForAccounts;

    function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，将此行添加到&lt;strong&gt;transfer&lt;/strong&gt;功能，以便发件人退款：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /* Send coins */
    function transfer(address _to, uint256 _value) {
        ...
        if(msg.sender.balance &amp;lt; minBalanceForAccounts)
            sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种做法是，发送者检测收款方有没有足够的ETH，如果没有，发送者则兑换一部分自己的代币，将得到的ETH发送给收款方（这种做法就是为收款方服务，收款方不用处理ETH、GAS的事情）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /* Send coins */
    function transfer(address _to, uint256 _value) {
        ...
        if(_to.balance&amp;lt;minBalanceForAccounts)
            _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将确保不会有低于必要以太币的账户可以接受代币。&lt;/p&gt;

&lt;h1 id=&#34;高级版代币&#34;&gt;高级版代币&lt;/h1&gt;

&lt;h2 id=&#34;全部代码&#34;&gt;全部代码&lt;/h2&gt;

&lt;p&gt;如果你打算添加所有高级的高能,下面是最终代码:&lt;/p&gt;

&lt;p&gt;注意:原示例中存在几处bug已经修正。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pragma solidity 0.4.21;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }

/**
 * owned 是一个管理者
 */
contract owned {
    address public owner;

    /**
     * 初台化构造函数
     */
    function owned() public{
        owner = msg.sender;
    }

    /**
     * 判断当前合约调用者是否是管理员
     */
    modifier onlyOwner {
        require (msg.sender == owner);
        _;
    }

    /**
     * 指派一个新的管理员
     * @param  newOwner address 新的管理员帐户地址
     */
    function transferOwnership(address newOwner) onlyOwner public{
        owner = newOwner;
    }
}

/**
 * @title 基础版的代币合约
 */
contract TokenERC20 {
    /* 公共变量 */
    string public name; //代币名称
    string public symbol; //代币符号比如&#39;$&#39;
    uint8 public decimals = 18;  //代币精度，展示的小数点后面多少个0,和以太币一样后面是是18个0
    uint256 public totalSupply; //代币总量

    /*记录所有余额的映射*/
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    /* 在区块链上创建一个事件，用以通知客户端*/
    event Transfer(address indexed from, address indexed to, uint256 value);  //转帐通知事件
    event Burn(address indexed from, uint256 value);  //减去用户余额事件

    /* 构造函数
     * 初始化合约，并且把初始的所有代币都给这合约的创建者
     * @param initialSupply 代币的总数
     * @param tokenName 代币名称
     * @param tokenSymbol 代币符号
     */
    function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public{

        //初始化总量
        totalSupply = initialSupply * 10 ** uint256(decimals);    //使用精度来更新总量

        //初始化总量赋值给创建者
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;

    }


    /**
     * 私有方法从一个帐户发送给另一个帐户代币，只能合约内部调用
     * @param  _from address 发送代币的地址
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function _transfer(address _from, address _to, uint256 _value) internal {

      //避免转帐的地址是0x0
      require(_to != 0x0);

      //检查发送者是否拥有足够余额
      require(balanceOf[_from] &amp;gt;= _value);

      //检查是否溢出
      require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);

      //保存数据用于后面的判断
      uint previousBalances = balanceOf[_from] + balanceOf[_to];

      //从发送者减掉发送额
      balanceOf[_from] -= _value;

      //给接收者加上相同的量
      balanceOf[_to] += _value;

      //通知任何监听该交易的客户端
      emit Transfer(_from, _to, _value);

      //判断买、卖双方的数据是否和转换前一致
      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }

    /**
     * 从主帐户合约调用者发送给别人代币
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * 从某个指定的帐户中，向另一个帐户发送代币
     *
     * 调用过程，会检查设置的允许最大交易额
     *
     * @param  _from address 发送者地址
     * @param  _to address 接受者地址
     * @param  _value uint256 要转移的代币数量
     * @return success        是否交易成功
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        //检查发送者是否拥有足够余额
        require(_value &amp;lt;= allowance[_from][msg.sender]);   // Check allowance

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;
    }

    /**
     * 设置帐户允许支付的最大金额
     *
     * 一般在智能合约的时候，避免支付过多，造成风险
     *
     * @param _spender 帐户地址
     * @param _value 金额
     */
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * 设置帐户允许支付的最大金额
     *
     * 一般在智能合约的时候，避免支付过多，造成风险，加入时间参数，可以在 tokenRecipient 中做其他操作
     *
     * @param _spender 帐户地址
     * @param _value 金额
     * @param _extraData 操作的时间
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * 减少代币调用者的余额
     *
     * 操作以后是不可逆的
     *
     * @param _value 要删除的数量
     */
    function burn(uint256 _value) public returns (bool success) {
        //检查帐户余额是否大于要减去的值
        require(balanceOf[msg.sender] &amp;gt;= _value);   // Check if the sender has enough

        //给指定帐户减去余额
        balanceOf[msg.sender] -= _value;

        //代币问题做相应扣除
        totalSupply -= _value;

        emit Burn(msg.sender, _value);
        return true;
    }

    /**
     * 删除帐户的余额（含其他帐户）
     *
     * 删除以后是不可逆的
     *
     * @param _from 要操作的帐户地址
     * @param _value 要减去的数量
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        //检查帐户余额是否大于要减去的值
        require(balanceOf[_from] &amp;gt;= _value);

        //检查 其他帐户 的余额是否够使用
        require(_value &amp;lt;= allowance[_from][msg.sender]);

        //减掉代币
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;

        //更新总量
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
}

/**
 * @title 高级版代币
 * 增加冻结用户、挖矿、根据指定汇率购买(售出)代币价格的功能
 */
contract MyAdvancedToken is owned, TokenERC20 {

    //卖出价格 单位是wei
    uint256 public sellPrice;

    //买入价格
    uint256 public buyPrice;

    //是否冻结帐户的列表
    mapping (address =&amp;gt; bool) public frozenAccount;

    //定义一个事件，当有资产被冻结的时候，通知正在监听事件的客户端
    event FrozenFunds(address target, bool frozen);


    /*初始化合约，并且把初始的所有的令牌都给这合约的创建者
     * @param initialSupply 所有币的总数
     * @param tokenName 代币名称
     * @param tokenSymbol 代币符号
     */
    function MyAdvancedToken(
      uint256 initialSupply,
      string tokenName,
      string tokenSymbol
    ) public TokenERC20 (initialSupply, tokenName, tokenSymbol) {
     //初始化操作
    }


    /**
     * 私有方法，从指定帐户转出余额
     * @param  _from address 发送代币的地址
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function _transfer(address _from, address _to, uint _value) internal {

        //避免转帐的地址是0x0
        require (_to != 0x0);

        //检查发送者是否拥有足够余额
        require (balanceOf[_from] &amp;gt;= _value);

        //检查是否溢出
        require (balanceOf[_to] + _value &amp;gt;= balanceOf[_to]);

        //检查 冻结帐户
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);



        //从发送者减掉发送额
        balanceOf[_from] -= _value;

        //给接收者加上相同的量
        balanceOf[_to] += _value;

        //通知任何监听该交易的客户端
        emit Transfer(_from, _to, _value);

    }

    /**
     * 合约拥有者，可以为指定帐户创造一些代币
     * @param  target address 帐户地址
     * @param  mintedAmount uint256 增加的金额(单位是wei)
     */
    function mintToken(address target, uint256 mintedAmount) onlyOwner public{

        //给指定地址增加代币，同时总量也相加
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;


        emit Transfer(0, this, mintedAmount);
        emit Transfer(this, target, mintedAmount);
    }

    /**
     * 增加冻结帐户名称
     *
     * 你可能需要监管功能以便你能控制谁可以/谁不可以使用你创建的代币合约
     *
     * @param  target address 帐户地址
     * @param  freeze bool    是否冻结
     */
    function freezeAccount(address target, bool freeze) onlyOwner public{
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    /**
     * 设置买卖价格
     *
     * 如果你想让ether(或其他代币)为你的代币进行背书,以便可以市场价自动化买卖代币,我们可以这么做。如果要使用浮动的价格，也可以在这里设置
     *
     * @param newSellPrice 新的卖出价格
     * @param newBuyPrice 新的买入价格
     */
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public{
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /**
     * 使用以太币购买代币,通过增加关键字 payable 我们就可以从任何账户接受以太币来调用这个函数。
     */
    function buy() payable public {
      uint amount = msg.value / buyPrice;

      _transfer(this, msg.sender, amount);
    }

    /**
     * @dev 卖出代币
     * @return 要卖出的数量(单位是wei)
     */
    function sell(uint256 amount) public {

        //检查合约的余额是否充足
        require(address(this).balance &amp;gt;= amount * sellPrice);

        _transfer(msg.sender, this, amount);

        msg.sender.transfer(amount * sellPrice);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;

&lt;p&gt;复制修正后代码到部署界面,选择My Advanced Token,填写相应的参数,发布即可。
&lt;img src=&#34;https://www.3afun.com/media/images/2018/deploy11.png&#34; alt=&#34;deplpy&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;

&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;账号&lt;/th&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;CoolCoin&lt;/th&gt;
&lt;th&gt;Ether&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Main account&lt;/td&gt;
&lt;td&gt;0x914995c9c3c993C9D3Fdd63602c91823F932b308&lt;/td&gt;
&lt;td&gt;9800&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Account 2&lt;/td&gt;
&lt;td&gt;0x30Ed8Cd207dfdAF5E24847252DF822b1DA1F2FE5&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Account 3&lt;/td&gt;
&lt;td&gt;0x379f0f61dF4D9009C1AB7BDEA409F5465b5D940c&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Account 4&lt;/td&gt;
&lt;td&gt;0xc2298C3398584aaB380fafb564037D9Fb910e0a1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-set-prices-测试&#34;&gt;1.Set prices 测试&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;实验:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在合约管理界面,通过Set Prices函数,我们可以设置&lt;/p&gt;

&lt;p&gt;New sell price =  1&lt;/p&gt;

&lt;p&gt;New buy price = 2&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;等到同步一个区块后,发现管理界面Sell price 和 Buy Price已经更新。&lt;/p&gt;

&lt;h3 id=&#34;2-approve-allowance-transfer-from-测试&#34;&gt;2.Approve &amp;amp; Allowance &amp;amp;Transfer From 测试&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;实验1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过账户2授权10个CoolCoin给账户3&lt;/p&gt;

&lt;p&gt;Approve(Account2, 100)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin01.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过Allowance查看账户2拥有账户3的授权额度&lt;/p&gt;

&lt;p&gt;Allowance(Account 2, Account 3) = 10&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin02.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实验2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过Transfer From函数,账户3将账户2账户的10个Cool Coin转给账户4&lt;/p&gt;

&lt;p&gt;Transfer From(Account2, Account4,10)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin03.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Balance of(Account2) = 90&lt;/p&gt;

&lt;p&gt;Balance of(Account4) = 10&lt;/p&gt;

&lt;p&gt;Allowance(Account 2, Account 3) = 0&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;账号&lt;/th&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;CoolCoin&lt;/th&gt;
&lt;th&gt;Ether&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Main account&lt;/td&gt;
&lt;td&gt;0x914995c9c3c993C9D3Fdd63602c91823F932b308&lt;/td&gt;
&lt;td&gt;9800&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Account 2&lt;/td&gt;
&lt;td&gt;0x30Ed8Cd207dfdAF5E24847252DF822b1DA1F2FE5&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;td&gt;0,999212698&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Account 3&lt;/td&gt;
&lt;td&gt;0x379f0f61dF4D9009C1AB7BDEA409F5465b5D940c&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Account 4&lt;/td&gt;
&lt;td&gt;0xc2298C3398584aaB380fafb564037D9Fb910e0a1&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其他条件测试可自行进行。&lt;/p&gt;

&lt;h3 id=&#34;3-burn-测试&#34;&gt;3.Burn 测试&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;实验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;销毁账户4的5个Cool Coin&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin04.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;账户4 还剩下5个Cool Coin,Total supply 同步也会减少5个。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin05.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-mint-token-测试&#34;&gt;4.Mint Token 测试&lt;/h3&gt;

&lt;p&gt;账户4挖5个Cool Coin&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin06.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;账户4 此时有10个Cool Coin&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin07.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-burn-from-测试&#34;&gt;5.Burn From 测试&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;实验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;账户2通过Burn From函数销毁账户3的 10个CoolCoin&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin08.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行失败,原因是账户2不具有账户3的授权额度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin09.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么我们可以将账户3的20个币授权给账户2再重新试一下&lt;/p&gt;

&lt;p&gt;授权&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin10.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时有Allowance(Account3, Account2)=20&lt;/p&gt;

&lt;p&gt;现在我们再次使用账户2来销毁账户3的10个币试一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin11.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在可以成功销毁账户3的10个币了&lt;/p&gt;

&lt;p&gt;此时有Allowance(Account3, Account2)=10&lt;/p&gt;

&lt;p&gt;当我们尝试再次销毁20个的时候,发现区块链拒绝我们的服务,但是我们销毁10个的话,还是可以允许的。&lt;/p&gt;

&lt;h3 id=&#34;6-buy测试&#34;&gt;6.Buy测试&lt;/h3&gt;

&lt;p&gt;通过Set prices 测试,我们已经完成的设置有:&lt;/p&gt;

&lt;p&gt;Buy Price = 1&lt;/p&gt;

&lt;p&gt;Sell price = 2&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于现在Cool Coin的管理界面账户里是没有Ether的,所以我们只能先用账户4来购买一些以太币。&lt;/p&gt;

&lt;p&gt;1.主账户发送100Ether给账户4&lt;/p&gt;

&lt;p&gt;2.测试账户4有100,890236054 ETHER和20个CoolCoin,现在我们使用账户4的10个Ether来购买CoolCoin。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin12.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;strong&gt;注意:我们购买代币,并不是从合约管理员Owner来扣除相应的代币,而是从合约地址来购买代币。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以我们需要先给合约地址充值代币,才能允许其他用户来购买,否则其他用户向一个代币为0的&amp;rdquo;央行&amp;rdquo;购买,是会购买不到。&lt;/p&gt;

&lt;p&gt;在此我们使用Mint Token函数来给合约地址 0x63b5047Decd4501d4eb3bb7b30e3da89cE37c2f5 充值 100万个。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin13.png&#34; alt=&#34;cool coin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;4.现在我们的&amp;rdquo;央行&amp;rdquo;&amp;ndash;CoolCoin(管理界面),拥有0个以太币,100万个Cool Coin&lt;/p&gt;

&lt;p&gt;账户4拥有100.890236054个以太币和20个CoolCoin&lt;/p&gt;

&lt;p&gt;回到合约管理界面,我们尝试使用账户4调用Buy函数,传入10个以太币,看看会发什么。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin14.png&#34; alt=&#34;购买&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没错!!!&lt;/p&gt;

&lt;p&gt;结果正是我们看到的,账户4以太币减少了10个。Cool Coin币增加了5个。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin15.png&#34; alt=&#34;购买&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同样可查看CoolCoin管理界面多了10个Ether。&lt;/p&gt;

&lt;h3 id=&#34;7-sell-测试&#34;&gt;7.Sell 测试&lt;/h3&gt;

&lt;p&gt;现在更激动人心的来了,我们要进行Sell测试,因为我们订的Buy Price = 2, Sell price = 1。账户4一买一卖我们会净赚一半!!!&lt;/p&gt;

&lt;p&gt;现在我们使用账户4卖出刚才买入的5个CoolCoin:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin16.png&#34; alt=&#34;卖出操作&#34; /&gt;&lt;/p&gt;

&lt;p&gt;卖出后,我们回到Account 4,发现我们成功卖出5个CoolCoin,得到5个以太币。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin17.png&#34; alt=&#34;卖出操作&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;8-freeze-account-测试&#34;&gt;8.Freeze Account 测试&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;实验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.现在我们进行冻结账户测试,我们选择冻结账户4&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin18.png&#34; alt=&#34;卖出操作&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.然后账户4授权20个币给账户2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin19.png&#34; alt=&#34;卖出操作&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们有&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin20.png&#34; alt=&#34;卖出操作&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了验证,我们选择使用2将账户4的10个币转账给账户3。结果提示交易会失败,符合预期。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin21.png&#34; alt=&#34;卖出操作&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2018/coolcoin22.png&#34; alt=&#34;卖出操作&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重新解冻后,我们就可以进行上面验证了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ubuntu16.04 搭建以太坊Ethereum私链(2)</title>
      <link>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE2/</link>
      <pubDate>Fri, 13 Apr 2018 16:18:49 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE2/</guid>
      
        <description>

&lt;p&gt;前面几篇文章我们介绍了私有链的服务器搭建和客户端连接私有服务器,接下来我们就要学习如何保证服务器端退出后还能继续提供稳定服务,解决客户端可以永久链接服务器,交易实时被处理。&lt;/p&gt;

&lt;h1 id=&#34;服务器端启动&#34;&gt;服务器端启动&lt;/h1&gt;

&lt;p&gt;为了让客户端可以链接,我们可以使用nohup命令来让服务器进行后台启动,但仅仅这样还是不够的,我们还应该允许服务器端支持客户端转账等API,我们就要使用&lt;code&gt;--rpcapi&lt;/code&gt; 参数来指定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup geth --identity TestNode --rpc --rpcaddr 0.0.0.0 --rpcport 8545 --rpcapi &amp;quot;db,eth,net,web3,personal,admin,miner&amp;quot; --datadir /home/ubuntu/ethereum/data0 --port 30303 --nodiscover --mine --minerthreads=1 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令可以来后台启动服务器,并且允许客户端进行远程API调用.
在此命令中我们使用了mine参数开启一个线程进行挖矿,我们是有理由这么操作的,因为如果不是这样,即使客户端发起了一笔远程交易,因为不能生产块数据,也还是不会处理转账。&lt;/p&gt;

&lt;p&gt;如果你还是想进入console控制台来向原来那样执行命令,可以使用如下命令来进入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth attach http://127.0.0.1:8545
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这篇文章结束后,我们在使用客户端操作时候,就可以实现实时处理我们的交易。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ethereum wallet以太坊钱包链接Geth Server私有链</title>
      <link>https://www.3afun.com/post/2018/ethereum-wallet%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E9%93%BE%E6%8E%A5geth-server%E7%A7%81%E6%9C%89%E9%93%BE/</link>
      <pubDate>Thu, 12 Apr 2018 18:31:44 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/ethereum-wallet%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E9%93%BE%E6%8E%A5geth-server%E7%A7%81%E6%9C%89%E9%93%BE/</guid>
      
        <description>

&lt;p&gt;上一篇文章里,我们讲到 &lt;a href=&#34;https://www.3afun.com/post/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE/&#34;&gt;Ubuntu16.04 搭建以太坊Ethereum私链&lt;/a&gt;
这次,我就要来介绍如何下载我们的钱包来链接我们的私有链。&lt;/p&gt;

&lt;h1 id=&#34;以太坊钱包wallet下载&#34;&gt;以太坊钱包Wallet下载&lt;/h1&gt;

&lt;p&gt;钱包下载,大家可以去 &lt;a href=&#34;https://github.com/ethereum/mist/releases&#34;&gt;这里&lt;/a&gt;下载。现在最新版本是0.10.0&lt;/p&gt;

&lt;p&gt;不管大家选择是 Ethereum Wallet 还是 Mist 都是可以的,这里我都下载了Mac版本的2个钱包。&lt;/p&gt;

&lt;p&gt;安装的话没有难度,正常安装就行。&lt;/p&gt;

&lt;h1 id=&#34;geth-server-私有链服务器端&#34;&gt;Geth Server 私有链服务器端&lt;/h1&gt;

&lt;p&gt;因为我是远程链接私有链不是本地链接,所有我采用了RPC 链接方式。&lt;/p&gt;

&lt;p&gt;Geth 启动方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth --identity &amp;quot;TestNode&amp;quot; --rpc --rpcaddr &amp;quot;0.0.0.0&amp;quot; --rpcport &amp;quot;8545&amp;quot; --datadir data0 --port &amp;quot;30303&amp;quot; --nodiscover console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此次我们加入了 &lt;code&gt;--rpcaddr&lt;/code&gt;参数来允许远程连接,默认是拒绝远程链接的,只能本地链接。&lt;/p&gt;

&lt;h1 id=&#34;客户端钱包wallet启动&#34;&gt;客户端钱包Wallet启动&lt;/h1&gt;

&lt;h2 id=&#34;mac&#34;&gt;Mac&lt;/h2&gt;

&lt;h3 id=&#34;ethereum-wallet-启动&#34;&gt;Ethereum Wallet 启动&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;/Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet&amp;quot; --rpc &amp;quot;http://YOUR_IP:8545&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mist-启动&#34;&gt;Mist 启动&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/Applications/Mist.app/Contents/MacOS/Mist --rpc http://YOUR_IP:8545
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;windows&#34;&gt;Windows&lt;/h2&gt;

&lt;h3 id=&#34;mist-启动-1&#34;&gt;Mist 启动&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;D:\Program Files\Mist-win64-0-10-0\Mist.exe&amp;quot; --rpc http://YOUR_IP:8545
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ethereum-wallet-启动-1&#34;&gt;Ethereum Wallet 启动&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;D:\Program Files\Ethereum-Wallet-win64-0-10-0\Ethereum Wallet.exe&amp;quot; --rpc http://YOUR_IP:8545
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请自行替换 &lt;code&gt;YOUR_IP&lt;/code&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ubuntu16.04 搭建以太坊Ethereum私链</title>
      <link>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE1/</link>
      <pubDate>Wed, 11 Apr 2018 15:43:48 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/ubuntu16.04-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8Aethereum%E7%A7%81%E9%93%BE1/</guid>
      
        <description>

&lt;h1 id=&#34;一-说明&#34;&gt;一、说明&lt;/h1&gt;

&lt;p&gt;想尝试基于以太坊的应用或者Tokens发布，无奈正常网络测试需要用Ether，购买麻烦，各步骤还得需要消耗以太币，不过我们可以搭建私有链来进行开发，话不多说，马上开始搭建我们自己的开发测试私有链。&lt;/p&gt;

&lt;h1 id=&#34;二-所需工具&#34;&gt;二、所需工具&lt;/h1&gt;

&lt;p&gt;1、以太坊客户端&lt;/p&gt;

&lt;p&gt;以太坊客户端用于接入以太坊网络，进行账户管理、交易、挖矿、智能合约相关的操作。&lt;/p&gt;

&lt;p&gt;目前有多种语言实现的客户端，常用的有 Go 语言实现的 go-ethereum 客户端 Geth，支持接入以太坊网络并成为一个完整节点，也可作为一个 HTTP-RPC 服务器对外提供 JSON-RPC 接口。&lt;/p&gt;

&lt;p&gt;其他的客户端有：智能合约编译器&lt;/p&gt;

&lt;p&gt;Parity：Rust 语言实现；&lt;/p&gt;

&lt;p&gt;cpp-ethereum：C++ 语言实现；&lt;/p&gt;

&lt;p&gt;ethereumjs-lib：JavaScript 语言实现；&lt;/p&gt;

&lt;p&gt;Ethereum(J)：Java 语言实现；&lt;/p&gt;

&lt;p&gt;ethereumH：Haskell 语言实现；&lt;/p&gt;

&lt;p&gt;pyethapp： Python 语言实现；&lt;/p&gt;

&lt;p&gt;ruby-ethereum：Ruby 语言实现；&lt;/p&gt;

&lt;p&gt;2、智能合约编译器&lt;/p&gt;

&lt;p&gt;以太坊支持两种智能合约的编程语言：Solidity 和 Serpent。现在的主流是Solidity，学习教程可参考 &lt;a href=&#34;http://www.tryblockchain.org/Solidity-%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D.html&#34;&gt;站点&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;现在以太坊提供更方便的在线 IDE —— Remix &lt;a href=&#34;https://remix.ethereum.org&#34;&gt;https://remix.ethereum.org&lt;/a&gt; 使用 Remix，免去了安装solc和编译过程，它可以直接提供部署合约所需的二进制码和 ABI。&lt;/p&gt;

&lt;p&gt;3、以太坊钱包&lt;/p&gt;

&lt;p&gt;以太坊提供了图形界面的钱包 Ethereum Wallet 和 Mist Dapp 浏览器。&lt;/p&gt;

&lt;p&gt;钱包的功能是 Mist 的一个子集，可用于管理账户和交易；Mist 在钱包基础上，还能操作智能合约。为了演示合约部署过程，本文使用了 Geth console 操作，没有用到 Mist，当然，使用 Mist 会更简单。&lt;/p&gt;

&lt;h1 id=&#34;三-安装&#34;&gt;三、安装&lt;/h1&gt;

&lt;p&gt;服务器我们采用Ubuntu16.04。&lt;/p&gt;

&lt;p&gt;首先安装必要的工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt install software-properties-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次添加以太坊源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-apt-repository -y ppa:ethereum/ethereum
apt update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后安装go-ethereum&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt install ethereum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，可以运行命令查看是否成功&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Geth
Version: 1.8.2-stable
Git Commit: b8b9f7f4476a30a0aaf6077daade6ae77f969960
Architecture: amd64
Protocol Versions: [63 62]
Network Id: 1
Go Version: go1.9.4
Operating System: linux
GOPATH=
GOROOT=/usr/lib/go-1.9
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-私有链搭建&#34;&gt;四、私有链搭建&lt;/h1&gt;

&lt;p&gt;1、创建初始化配置文件和存放数据目录&lt;/p&gt;

&lt;p&gt;要运行以太坊私有链，需要定义自己创世区块，创世区块是一个json格式配置文件。我们可以新建一个文件 genesis.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
&amp;quot;config&amp;quot;: {
    &amp;quot;chainId&amp;quot;: 411,
    &amp;quot;homesteadBlock&amp;quot;: 0,
    &amp;quot;eip155Block&amp;quot;: 0,
    &amp;quot;eip158Block&amp;quot;: 0
  },
  &amp;quot;nonce&amp;quot;: &amp;quot;0x0000000000000033&amp;quot;,
  &amp;quot;timestamp&amp;quot;: &amp;quot;0x0&amp;quot;,
  &amp;quot;parentHash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;gasLimit&amp;quot;: &amp;quot;0x8000000&amp;quot;,
  &amp;quot;difficulty&amp;quot;: &amp;quot;0x100&amp;quot;,
  &amp;quot;mixhash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;coinbase&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;alloc&amp;quot;: {
        &amp;quot;0x1C83C95473e1e93A2C8560c73976dAFA9C3f0a79&amp;quot;:{&amp;quot;balance&amp;quot;:&amp;quot;1000000&amp;quot;}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中chainID 指定了区块链网络ID。&lt;/p&gt;

&lt;p&gt;并且我对自己地址进行了配额。其他参数可参考 &lt;a href=&#34;http://www.tryblockchain.org/Solidity-%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D.html&#34;&gt;站点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;存放数据目录在此我使用 &lt;code&gt;/home/ubuntu/ethereum/data0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;genesis.json存放在&lt;code&gt;/home/ubuntu/ethereum/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后可以执行命令来进行初始化操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ethereum
geth --datadir data0 init genesis.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INFO [04-11|07:51:14] Maximum peer count                       ETH=25 LES=0 total=25
INFO [04-11|07:51:14] Allocated cache and file handles         database=/home/ubuntu/ethereum/data0/geth/chaindata cache=16 handles=16
INFO [04-11|07:51:14] Writing custom genesis block
INFO [04-11|07:51:14] Persisted trie from memory database      nodes=1 size=195.00B time=35.174碌s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [04-11|07:51:14] Successfully wrote genesis state         database=chaindata                                  hash=b924d6Ωfdceb
INFO [04-11|07:51:14] Allocated cache and file handles         database=/home/ubuntu/ethereum/data0/geth/lightchaindata cache=16 handles=16
INFO [04-11|07:51:14] Writing custom genesis block
INFO [04-11|07:51:14] Persisted trie from memory database      nodes=1 size=195.00B time=460.134碌s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [04-11|07:51:14] Successfully wrote genesis state         database=lightchaindata                                  hash=b924d6Ωfdceb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化成功后，会在data0目录下生产所需文件。&lt;/p&gt;

&lt;p&gt;其中 &lt;code&gt;geth/chaindata&lt;/code&gt; 中存放的是区块数据，&lt;code&gt;keystore&lt;/code&gt; 中存放的是账户数据。&lt;/p&gt;

&lt;h1 id=&#34;五-启动私有节点&#34;&gt;五、启动私有节点&lt;/h1&gt;

&lt;p&gt;初始化完成后，就有了一条自己的私有链。我们可以执行命令来启动它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth --identity &amp;quot;TestNode&amp;quot; --rpc --rpcport &amp;quot;8545&amp;quot; --datadir data0 --port &amp;quot;30303&amp;quot; --nodiscover console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令的主体是 geth console，表示启动节点并进入交互式控制台。&lt;/p&gt;

&lt;p&gt;各选项含义如下：&lt;/p&gt;

&lt;p&gt;–identity：指定节点 ID；&lt;/p&gt;

&lt;p&gt;–rpc：表示开启 HTTP-RPC 服务；&lt;/p&gt;

&lt;p&gt;–rpcport：指定 HTTP-RPC 服务监听端口号（默认为 8545）；&lt;/p&gt;

&lt;p&gt;–datadir：指定区块链数据的存储位置；&lt;/p&gt;

&lt;p&gt;–port：指定和其他节点连接所用的端口号（默认为 30303）；&lt;/p&gt;

&lt;p&gt;–nodiscover：关闭节点发现机制，防止加入有同样初始配置的陌生节点。&lt;/p&gt;

&lt;p&gt;运行上面的命令后，就启动了区块链节点并进入了该节点的控制台：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INFO [04-11|08:05:23] Maximum peer count                       ETH=25 LES=0 total=25
INFO [04-11|08:05:23] Starting peer-to-peer node               instance=Geth/TestNode/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4
INFO [04-11|08:05:23] Allocated cache and file handles         database=/home/ubuntu/ethereum/data0/data0/geth/chaindata cache=768 handles=512
INFO [04-11|08:05:23] Writing default main-net genesis block
INFO [04-11|08:05:23] Persisted trie from memory database      nodes=12356 size=2.34mB time=47.705254ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [04-11|08:05:23] Initialised chain configuration          config=&amp;quot;{ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Byzantium: 4370000 Constantinople: &amp;lt;nil&amp;gt; Engine: ethash}&amp;quot;
INFO [04-11|08:05:23] Disk storage enabled for ethash caches   dir=/home/ubuntu/ethereum/data0/data0/geth/ethash count=3
INFO [04-11|08:05:23] Disk storage enabled for ethash DAGs     dir=/root/.ethash                                 count=2
INFO [04-11|08:05:23] Initialising Ethereum protocol           versions=&amp;quot;[63 62]&amp;quot; network=1
INFO [04-11|08:05:23] Loaded most recent local header          number=0 hash=d4e567b8fa3 td=17179869184
INFO [04-11|08:05:23] Loaded most recent local full block      number=0 hash=d4e567b8fa3 td=17179869184
INFO [04-11|08:05:23] Loaded most recent local fast block      number=0 hash=d4e567b8fa3 td=17179869184
INFO [04-11|08:05:23] Regenerated local transaction journal    transactions=0 accounts=0
INFO [04-11|08:05:23] Starting P2P networking
INFO [04-11|08:05:23] RLPx listener up                         self=&amp;quot;enode://b5e91ca148308d721599ac14b9f2a9aff28c88b258a439fbc19f094d65ecaa9954a6a7d0de29f5737726bcdb20a443db9edeedce0471c1ba5cda043e8601e0d0@[::]:30303?discport=0&amp;quot;
INFO [04-11|08:05:23] IPC endpoint opened                      url=/home/ubuntu/ethereum/data0/data0/geth.ipc
INFO [04-11|08:05:23] HTTP endpoint opened                     url=http://127.0.0.1:8545                      cors= vhosts=localhost
Welcome to the Geth JavaScript console!

instance: Geth/TestNode/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个交互式的 JavaScript 执行环境，在这里面可以执行 JavaScript 代码，其中 &lt;code&gt;&amp;gt;&lt;/code&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的 JavaScript 对象，可以直接使用这些对象。这些对象主要包括：&lt;/p&gt;

&lt;p&gt;eth：包含一些跟操作区块链相关的方法；&lt;/p&gt;

&lt;p&gt;net：包含一些查看p2p网络状态的方法；&lt;/p&gt;

&lt;p&gt;admin：包含一些与管理节点相关的方法；&lt;/p&gt;

&lt;p&gt;miner：包含启动&amp;amp;停止挖矿的一些方法；&lt;/p&gt;

&lt;p&gt;personal：主要包含一些管理账户的方法；&lt;/p&gt;

&lt;p&gt;txpool：包含一些查看交易内存池的方法；&lt;/p&gt;

&lt;p&gt;web3：包含了以上对象，还包含一些单位换算的方法。&lt;/p&gt;

&lt;h1 id=&#34;六-控制台操作&#34;&gt;六、控制台操作&lt;/h1&gt;

&lt;p&gt;进入以太坊 Javascript Console 后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。&lt;/p&gt;

&lt;p&gt;常用命令有：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;personal.newAccount()&lt;/code&gt;：创建账户；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;personal.unlockAccount()&lt;/code&gt;：解锁账户；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.accounts&lt;/code&gt;：枚举系统中的账户；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.getBalance()&lt;/code&gt;：查看账户余额，返回值的单位是 Wei（Wei 是以太坊中最小货币面额单位，类似比特币中的聪，1 ether = 10^18 Wei）；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.blockNumber&lt;/code&gt;：列出区块总数；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.getTransaction()&lt;/code&gt;：获取交易；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eth.getBlock()&lt;/code&gt;：获取区块；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;miner.start()&lt;/code&gt;：开始挖矿；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;miner.stop()&lt;/code&gt;：停止挖矿；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;web3.fromWei()&lt;/code&gt;：Wei 换算成以太币；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;web3.toWei()&lt;/code&gt;：以太币换算成 Wei；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;txpool.status&lt;/code&gt;：交易池中的状态；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;admin.addPeer()&lt;/code&gt;：连接到其他节点；&lt;/p&gt;

&lt;p&gt;这些命令支持 Tab 键自动补全，具体用法如下。&lt;/p&gt;

&lt;h2 id=&#34;1-创建账户&#34;&gt;1、创建账户&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;personal.newAccount()
Passphrase:
Repeat passphrase:
&amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入密码、确认密码将会创建一个账户.&lt;/p&gt;

&lt;p&gt;同样方法再创建一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; personal.newAccount()
Passphrase:
Repeat passphrase:
&amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看账户(上面初始化配置文件出差错了？没分配呀)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.accounts
[&amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;, &amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-查看账户余额&#34;&gt;2、查看账户余额&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;eth.getBalance(eth.accounts[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-启动-停止挖矿&#34;&gt;3、启动 停止挖矿&lt;/h2&gt;

&lt;h3 id=&#34;启动挖矿&#34;&gt;启动挖矿&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;miner.start(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 start 的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的 DAG 文件，这个过程有点慢，等进度达到 100% 后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。&lt;/p&gt;

&lt;h3 id=&#34;停止挖矿&#34;&gt;停止挖矿&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;miner.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做 coinbase，默认情况下 coinbase 是本地账户中的第一个账户，可以通过 miner.setEtherbase() 将其他账户设置成 coinbase。&lt;/p&gt;

&lt;p&gt;再次查看账户余额&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
510000000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-发送交易&#34;&gt;4、发送交易&lt;/h2&gt;

&lt;p&gt;目前，账户0已经挖到了97个块的奖励，账户1余额还是0：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
510000000000000000000
&amp;gt; eth.getBalance(eth.accounts[1])
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们要从账户0到账户1转账，需要先解锁账户0才能转账&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; personal.unlockAccount(eth.accounts[0])
Unlock account 0x914995c9c3c993c9d3fdd63602c91823f932b308
Passphrase:
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转账0-&amp;gt;1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; amount = web3.toWei(5,&#39;ether&#39;)
&amp;quot;5000000000000000000&amp;quot;
&amp;gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})
INFO [04-11|09:37:09] Submitted transaction                    fullhash=0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973 recipient=0x30Ed8Cd207dfdAF5E24847252DF822b1DA1F2FE5
&amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时如果没有挖矿，用 txpool.status 命令可以看到本地交易池中有一个待确认的交易，可以使用 &lt;code&gt;eth.getBlock(&amp;quot;pending&amp;quot;, true).transactions&lt;/code&gt; 查看当前待确认交易。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; txpool.status
{
  pending: 1,
  queued: 0
}
&amp;gt; eth.getBlock(&amp;quot;pending&amp;quot;, true).transactions
[{
    blockHash: &amp;quot;0x2a13705bbe3a60c1d8fa686d6c8a326c6f1b70e7943bb7be8d8e9aa9fef7701e&amp;quot;,
    blockNumber: 103,
    from: &amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;,
    gas: 90000,
    gasPrice: 18000000000,
    hash: &amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;,
    input: &amp;quot;0x&amp;quot;,
    nonce: 0,
    r: &amp;quot;0x546055f53f1f7535549c4e31ddf03c6678384afc9571240d237823c205239a11&amp;quot;,
    s: &amp;quot;0x65f39c6a35f338c6fe67faf7a3bb14c91abc0472113bb9916c82cc51a407f6c9&amp;quot;,
    to: &amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;,
    transactionIndex: 0,
    v: &amp;quot;0x359&amp;quot;,
    value: 5000000000000000000
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;miner.start()&lt;/code&gt; 命令开始挖矿：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; miner.start(1);admin.sleepBlocks(1);miner.stop();
INFO [04-11|09:39:49] Updated mining threads                   threads=1
INFO [04-11|09:39:49] Transaction pool price threshold updated price=18000000000
INFO [04-11|09:39:49] Starting mining operation
INFO [04-11|09:39:49] Commit new mining work                   number=103 txs=1 uncles=0 elapsed=378.402碌s
INFO [04-11|09:39:52] Successfully sealed new block            number=103 hash=8327606bec9
INFO [04-11|09:39:52]  block reached canonical chain          number=98  hash=9d43b286588
INFO [04-11|09:39:52]  mined potential block                  number=103 hash=8327606bec9
INFO [04-11|09:39:52] Commit new mining work                   number=104 txs=0 uncles=0 elapsed=231.591碌s
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新区块挖出后，挖矿结束，查看账户 1 的余额，已经收到了账户 0 的以太币：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&#39;ether&#39;)
5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-查看交易和区块&#34;&gt;5、查看交易和区块&lt;/h2&gt;

&lt;p&gt;查看当前区块总数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.blockNumber
103
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过交易 Hash 查看交易（Hash 值包含在上面交易返回值中）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getTransaction(&amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;)
{
  blockHash: &amp;quot;0x83276067a8ad0168cf1d9fabb089b7778024bc6700434f470d830decb4a6bec9&amp;quot;,
  blockNumber: 103,
  from: &amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;,
  gas: 90000,
  gasPrice: 18000000000,
  hash: &amp;quot;0x2d8342ce23ca00a61a66a9926d45e8516bd0edda18703770c72897d2b9c31973&amp;quot;,
  input: &amp;quot;0x&amp;quot;,
  nonce: 0,
  r: &amp;quot;0x546055f53f1f7535549c4e31ddf03c6678384afc9571240d237823c205239a11&amp;quot;,
  s: &amp;quot;0x65f39c6a35f338c6fe67faf7a3bb14c91abc0472113bb9916c82cc51a407f6c9&amp;quot;,
  to: &amp;quot;0x30ed8cd207dfdaf5e24847252df822b1da1f2fe5&amp;quot;,
  transactionIndex: 0,
  v: &amp;quot;0x359&amp;quot;,
  value: 5000000000000000000
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过区块号查看区块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getBlock(102)
{
  difficulty: 137514,
  extraData: &amp;quot;0xd783010802846765746887676f312e392e34856c696e7578&amp;quot;,
  gasLimit: 121486905,
  gasUsed: 0,
  hash: &amp;quot;0x09c0a05f1a76fa39222f965d0b3665550bb5a0ab518963c8d1c5280a7b13cf43&amp;quot;,
  logsBloom: &amp;quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  miner: &amp;quot;0x914995c9c3c993c9d3fdd63602c91823f932b308&amp;quot;,
  mixHash: &amp;quot;0x7afd2e352e797ad57554bd81d1f156baed041242fcb641c336683fc9f5937b6c&amp;quot;,
  nonce: &amp;quot;0x4fe257812731bb15&amp;quot;,
  number: 102,
  parentHash: &amp;quot;0xaf1c22536346d8183b63632e4eb6fae81bfd5f9ca305f5fe20b9b7ef0da2a9de&amp;quot;,
  receiptsRoot: &amp;quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&amp;quot;,
  sha3Uncles: &amp;quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&amp;quot;,
  size: 536,
  stateRoot: &amp;quot;0x73bb0a88af2d04b4fcec031a48ffdc16cda90b88c215e3587f1e9acc1c050eca&amp;quot;,
  timestamp: 1523438740,
  totalDifficulty: 13695386,
  transactions: [],
  transactionsRoot: &amp;quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&amp;quot;,
  uncles: []
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>ERC223 标准规范</title>
      <link>https://www.3afun.com/post/2018/erc-223-token-standard/</link>
      <pubDate>Mon, 09 Apr 2018 15:43:48 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/erc-223-token-standard/</guid>
      
        <description>

&lt;p&gt;翻译自 &lt;a href=&#34;https://github.com/ethereum/EIPs/issues/223&#34;&gt;https://github.com/ethereum/EIPs/issues/223&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;抽象&#34;&gt;抽象&lt;/h1&gt;

&lt;p&gt;以下描述了标准代币合约函数和特定的代币,这样的实现代币可以避免意外发送到合约,可以是代币事物表现的像其他事务一样。&lt;/p&gt;

&lt;h1 id=&#34;动机&#34;&gt;动机&lt;/h1&gt;

&lt;p&gt;以下描述了ER223解决的ERC20代币规范的问题:
ERC20代币规范会导致退出用户的金钱损失.主要的问题是无法处理传入的ERC20事务,该事务是指通过 ERC20规范中 &lt;code&gt;transfer&lt;/code&gt; 函数执行的。&lt;/p&gt;

&lt;p&gt;如果你发送100个 ETH到一个不支持Ether的合约地址,那么他会拒绝交易并没有什么坏事发生。
如果您发送100个 ERC20代币到一个不支持ERC20的代币合约地址,那么他不会被拒绝,因为它能识别传入事务,所以会导致你的代币在你的余额里被卡住。&lt;/p&gt;

&lt;p&gt;比起ERC20,ERC23里解决的是:&lt;/p&gt;

&lt;p&gt;1.缺少 &lt;code&gt;transfer&lt;/code&gt; 处理的可能性。&lt;/p&gt;

&lt;p&gt;2.代币丢失。&lt;/p&gt;

&lt;p&gt;3.代币交易应该符合以太坊思想。当一个用户想交易的时候,他应该一直是通过调用 &lt;code&gt;transfer&lt;/code&gt;.用户是存一个新合约还是发送给一个外部账户,这都是无关紧要的.&lt;/p&gt;

&lt;p&gt;这些讲允许合约处理传入的代币事务并且阻止意外发送的和合约接受的代币(卡在余额中)&lt;/p&gt;

&lt;p&gt;例如,去中心化的交易不再需要用户调用 &lt;code&gt;approve&lt;/code&gt; 然后调用 &lt;code&gt;deposit&lt;/code&gt;(内部调用 &lt;code&gt;transferFrom&lt;/code&gt;用来取出批准的代币). 代币事务会在交易合约中自动处理.&lt;/p&gt;

&lt;p&gt;这里最重要的是在执行合约时调用 &lt;code&gt;tokenFallback&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;规范&#34;&gt;规范&lt;/h1&gt;

&lt;h1 id=&#34;代币-tokens&#34;&gt;代币(Tokens)&lt;/h1&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;注意:合约开发者如果想他们的合约支持特定代币,那么他们必须实现&lt;code&gt;tokenFallback&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果接受者没有实现 &lt;code&gt;tokenFallback&lt;/code&gt;函数,考虑合约不是设计用来支持代币,那么交易必定失败并且不会有代币被转账.
类比以太币交易,当发送以太币到一个没有实现 &lt;code&gt;function() payable&lt;/code&gt;的合约地址,也是会失败。&lt;/p&gt;

&lt;h3 id=&#34;totalsupply&#34;&gt;totalSupply&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function totalSupply() constant returns (uint256 totalSupply)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回代币总量&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function name() constant returns (string _name)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回代币名字&lt;/p&gt;

&lt;h3 id=&#34;symbol&#34;&gt;symbol&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function symbol() constant returns (bytes32 _symbol)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回代币符号&lt;/p&gt;

&lt;h3 id=&#34;decimals&#34;&gt;decimals&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function decimals() constant returns (uint8 _decimals)&lt;/code&gt;
返回精度&lt;/p&gt;

&lt;h3 id=&#34;balanceof&#34;&gt;balanceOf&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function balanceOf(address _owner) constant returns (uint256 balance)&lt;/code&gt;
返回 address _owner 的余额&lt;/p&gt;

&lt;h3 id=&#34;transfer-address-uint&#34;&gt;transfer(address, uint)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function transfer(address _to, uint _value) returns (bool)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为 ERC20 &lt;code&gt;transfer&lt;/code&gt; 函数没有 &lt;code&gt;bytes&lt;/code&gt; 参数,所以需要向后兼容.
该函数必须必须传输令牌并调&lt;code&gt;_to&lt;/code&gt;中的函数&lt;code&gt;tokenFallback(address,uint256,bytes)&lt;/code&gt;。
如果&lt;code&gt;_to&lt;/code&gt;（接收方合同）中没有实现&lt;code&gt;tokenFallback&lt;/code&gt;函数，则事务必须失败，并且不会发生令牌的传输。&lt;/p&gt;

&lt;p&gt;注意:将在接收方合约中调用的令牌备用功能必须命名为&lt;code&gt;tokenFallback&lt;/code&gt;，并使用参数&lt;code&gt;address,uint256，bytes&lt;/code&gt;。 此函数必须具有0xc0ee0b8a签名。&lt;/p&gt;

&lt;h3 id=&#34;transfer-address-uint-bytes&#34;&gt;transfer(address, uint, bytes)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function transfer(address _to, uint _value, bytes _data) returns (bool)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该函数总是在某人想转移代币的时候调用。&lt;/p&gt;

&lt;h2 id=&#34;事件&#34;&gt;事件&lt;/h2&gt;

&lt;h3 id=&#34;transfer&#34;&gt;Transfer&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;转移代币时候触发.&lt;/p&gt;

&lt;h2 id=&#34;contract合约和tokens-代币-一起工作&#34;&gt;Contract合约和tokens 代币 一起工作&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;function tokenFallback(address _from, uint _value, bytes _data)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一个处理代币转移的函数,当代币持有者发送代币时候由代币合约来调用.
&lt;code&gt;_from&lt;/code&gt;指代币发送者 &lt;code&gt;_value&lt;/code&gt;是收入代币的数量,&lt;code&gt;_data&lt;/code&gt;是附加数据,类似于以太币交易中的&lt;code&gt;msg.data&lt;/code&gt;.
它类似于Ether事务的fallback功能，并且什么也不返回。&lt;/p&gt;

&lt;h2 id=&#34;推荐的实现&#34;&gt;推荐的实现&lt;/h2&gt;

&lt;p&gt;这是一个强烈推荐的ERC223的代币实现 &lt;a href=&#34;https://github.com/Dexaran/ERC23-tokens/tree/Recommended&#34;&gt;https://github.com/Dexaran/ERC23-tokens/tree/Recommended&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ERC20 标准规范</title>
      <link>https://www.3afun.com/post/2018/erc-20-token-standard/</link>
      <pubDate>Wed, 04 Apr 2018 15:43:48 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2018/erc-20-token-standard/</guid>
      
        <description>

&lt;h1 id=&#34;简要说明&#34;&gt;简要说明&lt;/h1&gt;

&lt;p&gt;该文主要是一个以太币智能合约的标准接口说明。&lt;/p&gt;

&lt;h1 id=&#34;抽象&#34;&gt;抽象&lt;/h1&gt;

&lt;p&gt;以下将要说明的标准允许你去实现基于智能合约的标准代币（Tokens）API提供的接口。这个标准提供了一些基本功能以用于代币（Tokens）转账，以及批准用于其他链上的第三方来使用。&lt;/p&gt;

&lt;h1 id=&#34;动机&#34;&gt;动机&lt;/h1&gt;

&lt;p&gt;标准接口允许以太坊上的任何代币（Tokens）可以被其他程序来重新使用：包括钱包和去中心化的交换。&lt;/p&gt;

&lt;h1 id=&#34;规范&#34;&gt;规范&lt;/h1&gt;

&lt;h1 id=&#34;代币-tokens&#34;&gt;代币(Tokens)&lt;/h1&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;注意：调用者必须处理返回方法 &lt;code&gt;returns (bool success)&lt;/code&gt;返回的 &lt;code&gt;false&lt;/code&gt;.调用者绝对不能认为 &lt;code&gt;false&lt;/code&gt;从未返回。&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;name&lt;/h3&gt;

&lt;p&gt;返回代币的名字 ，例如 “MyToken”
可选 - 该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function name() view returns (string name)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;symbol&#34;&gt;symbol&lt;/h3&gt;

&lt;p&gt;返回代币的符号，例如“ETH”
可选 - 该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function symbol() view returns (string symbol)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;decimals&#34;&gt;decimals&lt;/h3&gt;

&lt;p&gt;返回代币的精确度，例如“8”，代币最小可以是0.00000001
可选 - 该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;该方法用来提高可用性，但是接口和其他合约不能期望这些值的呈现。&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;totalsupply&#34;&gt;totalSupply&lt;/h3&gt;

&lt;p&gt;返回代币的总量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function totalSupply() view returns (uint256 totalSupply)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;balanceof&#34;&gt;balanceOf&lt;/h3&gt;

&lt;p&gt;返回地址为 _owner 账户的 账户余额&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function balanceOf(address _owner) view returns (uint256 balance)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;transfer&#34;&gt;transfer&lt;/h3&gt;

&lt;p&gt;将 &lt;code&gt;_value&lt;/code&gt; 数量的代币（从外面账户）转到账户 &lt;code&gt;_to&lt;/code&gt;,并且必须调用 &lt;code&gt;Transfer&lt;/code&gt; 事件。如果 &lt;code&gt;_from&lt;/code&gt; 账户余额不够使用的话，该函数 应该抛出 &lt;code&gt;throw&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function transfer(address _to, uint256 _value) returns (bool success)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;transferfrom&#34;&gt;transferFrom&lt;/h3&gt;

&lt;p&gt;实现代币用户之间的交易，将 &lt;code&gt;_value&lt;/code&gt; 数量的代币从 &lt;code&gt;_from&lt;/code&gt; 账户转账到 &lt;code&gt;_to&lt;/code&gt;账户，并且必须调用 &lt;code&gt;Transfer&lt;/code&gt; 事件。
transferFrom 方法用于退出工作流程，允许合约代表你来转账。例如，这可以允许合约代替你来交易或者收取子货币的费用。该函数应该抛出 &lt;code&gt;throw&lt;/code&gt;，除非 &lt;code&gt;_from&lt;/code&gt; 账户通过某些机制授权消息的发送者。
注意：交易数量为 0 的转账须当做正常交易，并且应该调用 &lt;code&gt;Transfer&lt;/code&gt;事件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function transferFrom(address _from, address _to, uint256 _value) returns (bool success)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;approve&#34;&gt;approve&lt;/h3&gt;

&lt;p&gt;该方法允许发送者&lt;code&gt;_spender&lt;/code&gt;从你的账户多次取走最多为&lt;code&gt;_value&lt;/code&gt;限额数量的代币。如果这个方法再次被调用，那么他会用&lt;code&gt;_value&lt;/code&gt;的值覆盖当前可用限额。
注意:为了避免攻击，客户端应该以这样的方式来设置限额，在设置其他值给同一个发送者之前，先设置成0（尽管为了向后兼容之前的合约，合约不会执行它）.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function approve(address _spender, uint256 _value) returns (bool success)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;allowance&#34;&gt;allowance&lt;/h3&gt;

&lt;p&gt;返回发送者&lt;code&gt;_spender&lt;/code&gt;还剩下可从&lt;code&gt;_owner&lt;/code&gt;取走的额度。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function allowance(address _owner, address _spender) view returns (uint256 remaining)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;事件&#34;&gt;事件&lt;/h2&gt;

&lt;h3 id=&#34;transfer-1&#34;&gt;Transfer&lt;/h3&gt;

&lt;p&gt;该事件必须在交易代币（Tokens）的时候出发，包括数量为0的交易。
当创建新代币时应该触发一个 &lt;code&gt;Transfer&lt;/code&gt;事件，并将_from账户设置为&lt;code&gt;0x0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;event Transfer(address indexed _from, address indexed _to, uint256 _value)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;approval&#34;&gt;Approval&lt;/h3&gt;

&lt;p&gt;该事件必须在 成功调用 &lt;code&gt;approve(address _spender, uint256 _value)&lt;/code&gt;的时候触发。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;event Approval(address indexed _owner, address indexed _spender, uint256 _value)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;

&lt;p&gt;现在已经有很多的兼容ERC20标准并且基于以太坊网络的代币。有众多的团队根据接口来实现了不一样的代币，这些不同的实现包括节约费用Gas，提高安全性。
以下是一些可用的实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol&#34;&gt;https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol&#34;&gt;https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个再次调用 &lt;code&gt;approve&lt;/code&gt;前，设置0操作的实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol&#34;&gt;https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Network Error Unable to load the page的解决办法</title>
      <link>https://www.3afun.com/post/2017/network-error-unable-to-load-the-page%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Fri, 15 Dec 2017 13:42:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/network-error-unable-to-load-the-page%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      
        <description>&lt;p&gt;Cocos2d-x加载一个http页面A，A中其中含有一个链接到https页面B。现在B页面返回到A页面报错Unable to load the page.Please keep network connection.&lt;/p&gt;

&lt;p&gt;尝试B页面加载Https页面C没问题，返回A有问题。&lt;/p&gt;

&lt;p&gt;修改办法是，B页面的href链接 采用如下形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a class=&amp;quot;class_name&amp;quot; href=&amp;quot;//www.example.com&amp;quot;&amp;gt;A Page&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Crontab 定时执行任务的环境变量问题</title>
      <link>https://www.3afun.com/post/2017/crontab-%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 20 Nov 2017 17:27:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/crontab-%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</guid>
      
        <description>&lt;p&gt;今天写了一个脚本文件，有用到Python3中time库的localtime函数。在单独执行该脚本文件时候，可以支持获取服务器date时间。但是放在Crontab里定时执行的时候，发现获取的是格林尼治时间。明明系统已经更改到北京时间，为什么还会显示格林尼治时间呢？
怀疑是crontab执行时和单独执行py脚本时候，系统环境变量不一致。&lt;/p&gt;

&lt;p&gt;最终原先直接在crontab里定时执行py脚本，改为定时执行shell文件，在shell文件里通过记载用户环境变量，再执行py文件，成功获取到北京时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>使用Charles 进行https抓包</title>
      <link>https://www.3afun.com/post/2017/%E4%BD%BF%E7%94%A8charles-%E8%BF%9B%E8%A1%8Chttps%E6%8A%93%E5%8C%85/</link>
      <pubDate>Sat, 18 Nov 2017 16:57:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/%E4%BD%BF%E7%94%A8charles-%E8%BF%9B%E8%A1%8Chttps%E6%8A%93%E5%8C%85/</guid>
      
        <description>

&lt;h1 id=&#34;1-charles安装&#34;&gt;1. Charles安装&lt;/h1&gt;

&lt;p&gt;官网下载安装Charles:
&lt;a href=&#34;https://www.charlesproxy.com/download/&#34;&gt;https://www.charlesproxy.com/download/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-http抓包&#34;&gt;2. HTTP抓包&lt;/h1&gt;

&lt;h2 id=&#34;1-查看电脑ip地址&#34;&gt;（1）查看电脑IP地址&lt;/h2&gt;

&lt;h2 id=&#34;2-设置手机http代理&#34;&gt;（2）设置手机HTTP代理&lt;/h2&gt;

&lt;p&gt;手机连上电脑，点击“设置-&amp;gt;无线局域网-&amp;gt;连接的WiFi”&lt;/p&gt;

&lt;p&gt;设置HTTP代理：服务器为电脑IP地址：如192.168.0.100 端口：8888&lt;/p&gt;

&lt;p&gt;设置代理后，需要在电脑上打开Charles才能上网&lt;/p&gt;

&lt;h2 id=&#34;3-电脑上打开charles进行http抓包&#34;&gt;（3）电脑上打开Charles进行HTTP抓包&lt;/h2&gt;

&lt;p&gt;手机上打开某个App&lt;/p&gt;

&lt;p&gt;点击电脑上“Allow”允许，出现手机的HTTP请求列&lt;/p&gt;

&lt;h1 id=&#34;3-https抓包&#34;&gt;3. HTTPS抓包&lt;/h1&gt;

&lt;p&gt;HTTPS的抓包需要在HTTP抓包基础上再进行设置&lt;/p&gt;

&lt;p&gt;手机浏览器打开 &lt;a href=&#34;https://chls.pro/ssl&#34;&gt;https://chls.pro/ssl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;并安装证书，记得要信任该证书。&lt;/p&gt;

&lt;p&gt;注意：IOS 版本10.3+的，还需要额外设置：&lt;/p&gt;

&lt;p&gt;设置-&amp;gt;通用-&amp;gt;关于本机-&amp;gt;证书信任设置-&amp;gt;Charles Proxy CA 证书那里打开。&lt;/p&gt;

&lt;p&gt;至此大家可以试下Https抓包效果了。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/&#34;&gt;https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Sass 安装 及其常见错误的解决办法</title>
      <link>https://www.3afun.com/post/2017/sass-%E5%AE%89%E8%A3%85-%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Wed, 27 Sep 2017 10:51:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/sass-%E5%AE%89%E8%A3%85-%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      
        <description>&lt;p&gt;Sass是一种css的开发工具，它的安装依赖Ruby，没有安装Ruby的请先安装Ruby。&lt;/p&gt;

&lt;p&gt;假定你已经安装了Ruby，则可以直接执行如下语句进行安装。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install sass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见错误提示：&lt;/p&gt;

&lt;p&gt;1、ERROR:  While executing gem &amp;hellip; (OpenSSL::SSL::SSLError)&lt;/p&gt;

&lt;p&gt;hostname &amp;ldquo;gems.ruby-china.org&amp;rdquo; does not match the server certificate&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;p&gt;执行命令，查看数据源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem source -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*** CURRENT SOURCES ***

https://ruby.taobao.org/
https://gems.ruby-china.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则可以删除多余的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem sources --remove https://ruby.taobao.org/
sudo gem update --system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重新安装。&lt;/p&gt;

&lt;p&gt;2、ERROR:  SSL verification error at depth 1: unable to get local issuer certificate (20)&lt;/p&gt;

&lt;p&gt;ERROR:  You must add /O=Digital Signature Trust Co./CN=DST Root CA X3 to your local trusted store&lt;/p&gt;

&lt;p&gt;Fetching: ffi-1.9.18.gem ( 32%)ERROR:  SSL verification error at depth 2: self signed certificate in certificate chain (19)&lt;/p&gt;

&lt;p&gt;ERROR:  Root certificate is not trusted (/C=US/O=GeoTrust Inc./CN=GeoTrust Global CA)&lt;/p&gt;

&lt;p&gt;ERROR:  While executing gem &amp;hellip; (OpenSSL::SSL::SSLError)&lt;/p&gt;

&lt;p&gt;hostname &amp;ldquo;gems.ruby-china.org&amp;rdquo; does not match the server certificate&lt;/p&gt;

&lt;p&gt;3、ERROR:  SSL verification error at depth 1: unable to get local issuer certificate (20)&lt;/p&gt;

&lt;p&gt;ERROR:  You must add /O=Digital Signature Trust Co./CN=DST Root CA X3 to your local trusted store&lt;/p&gt;

&lt;p&gt;Fetching: ffi-1.9.18.gem (100%)&lt;/p&gt;

&lt;p&gt;Building native extensions.  This could take a while&amp;hellip;&lt;/p&gt;

&lt;p&gt;Successfully installed ffi-1.9.18&lt;/p&gt;

&lt;p&gt;ERROR:  SSL verification error at depth 2: self signed certificate in certificate chain (19)&lt;/p&gt;

&lt;p&gt;ERROR:  Root certificate is not trusted (/C=US/O=GeoTrust Inc./CN=GeoTrust Global CA)&lt;/p&gt;

&lt;p&gt;Fetching: rb-inotify-0.9.10.gem (100%)&lt;/p&gt;

&lt;p&gt;Successfully installed rb-inotify-0.9.10&lt;/p&gt;

&lt;p&gt;Fetching: sass-listen-4.0.0.gem (100%)&lt;/p&gt;

&lt;p&gt;Successfully installed sass-listen-4.0.0&lt;/p&gt;

&lt;p&gt;Fetching: sass-3.5.1.gem (100%)&lt;/p&gt;

&lt;p&gt;ERROR:  While executing gem &amp;hellip; (Errno::EPERM)&lt;/p&gt;

&lt;p&gt;Operation not permitted - /usr/bin/sass&lt;/p&gt;

&lt;p&gt;遇到以上错误 2和3的解决办法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem install -n /usr/local/bin sass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sass -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则会正确显示Sass版本号。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2017年12月28日更新：&lt;/p&gt;

&lt;p&gt;Mac更新系统后，Ruby由2.0升级到2.3，再次使用Sass时候，发现报错。&lt;/p&gt;

&lt;p&gt;于是决定升级SaaS，重新安装时遇到错误。最后找到解决方案：&lt;/p&gt;

&lt;p&gt;先安装libgmp-dev，再重新安装即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install libgmp-dev
sudo gem install -n /usr/local/bin sass
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Tomcat8 多实例 Unix daemon 模式 </title>
      <link>https://www.3afun.com/post/2017/tomcat8-%E5%A4%9A%E5%AE%9E%E4%BE%8B-unix-daemon-%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 11 Sep 2017 18:47:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/tomcat8-%E5%A4%9A%E5%AE%9E%E4%BE%8B-unix-daemon-%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;h1 id=&#34;一-事前准备&#34;&gt;一、事前准备&lt;/h1&gt;

&lt;p&gt;Tomcat8（版本8.5.20） &lt;a href=&#34;http://apache.spinellicreations.com/tomcat/tomcat-8/v8.5.20/bin/apache-tomcat-8.5.20.tar.gz&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;JDK8（版本号1.8.0_144） &lt;a href=&#34;http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;二-配置部署&#34;&gt;二、配置部署&lt;/h1&gt;

&lt;h3 id=&#34;目录说明&#34;&gt;目录说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;jdk 安装目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;/usr/java/jdk1.8.0_144&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tomcat 安装目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;/usr/tomcat/apache-tomcat-8.5.20&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目代码目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;data/web/forum&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tomcat实例目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;/data/web/tomcat8_forum8082&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;tomcat安装&#34;&gt;tomcat安装&lt;/h3&gt;

&lt;p&gt;1.生成jsvc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/tomcat/apache-tomcat-8.5.20/bin
tar xvfz commons-daemon-native.tar.gz
cd commons-daemon-1.0.x-native-src/unix
./configure --with-java=/usr/java/jdk1.8.0_144
make
cp jsvc ../..
cd ../..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.复制tomcat 安装目录的conf 配置文件到实例目录conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/tomcat/apache-tomcat-8.5.20/conf /data/web/tomcat8_forum8082
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.修改相应端口号，此处使用8082.&lt;/p&gt;

&lt;p&gt;4.在/data/web/tomcat8_forum8082目录下新建启动脚本&lt;/p&gt;

&lt;p&gt;&lt;em&gt;startup.sh&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

JRE_HOME=&amp;quot;/usr/java/jdk1.8.0_144&amp;quot;
JAVA_HOME=&amp;quot;/usr/java/jdk1.8.0_144&amp;quot;
SERVER_PATH=&amp;quot;/data/web&amp;quot;
LOGS_PATH=&amp;quot;/data/web/logs/forum&amp;quot;
CATALINA_HOME=&amp;quot;/usr/tomcat/apache-tomcat-8.5.20&amp;quot;
CATALINA_BASE=&amp;quot;/data/web/tomcat8_forum8082&amp;quot;
CATALINA_PID=&amp;quot;$SERVER_PATH/tomcat8_forum8082/pid&amp;quot;
JAVA_OPTS=&amp;quot;-Xms512m -Xmx512m &amp;quot;
#TOMCAT_USER=&amp;quot;app100681811&amp;quot;

#export JAVA_HOME JRE_HOME LOGS_PATH CATALINA_HOME CATALINA_BASE
export JAVA_HOME JRE_HOME LOGS_PATH #CATALINA_HOME CATALINA_BASE CATALINA_PID
echo $&amp;quot;tomcat8_forum8082 start&amp;quot;
#/usr/tomcat/apache-tomcat-8.5.20/bin/catalina.sh start
export LANG=en_US.UTF-8

cd $CATALINA_HOME
./bin/jsvc \
    -classpath $CATALINA_HOME/bin/bootstrap.jar:$CATALINA_HOME/bin/tomcat-juli.jar \
    -outfile $CATALINA_BASE/logs/catalina.out \
    -errfile $CATALINA_BASE/logs/catalina.err \
    -pidfile &amp;quot;$CATALINA_PID&amp;quot; \
    -Dcatalina.home=$CATALINA_HOME \
    -Dcatalina.base=$CATALINA_BASE \
    -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager \
    -Djava.util.logging.config.file=$CATALINA_BASE/conf/logging.properties \
    org.apache.catalina.startup.Bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭脚本&lt;/p&gt;

&lt;p&gt;&lt;em&gt;shutdown.sh&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $&amp;quot;tomcat8_forum8082 stop&amp;quot;
ps aux | grep jsvc |grep &#39;/web/tomcat8_forum8082&#39;| grep -v &#39;grep&#39; | awk -F &#39; &#39; &#39;{print $2}&#39; | xargs kill -s 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.执行相应脚本，即可完成启动关闭。&lt;/p&gt;

&lt;h1 id=&#34;三-多实例模式&#34;&gt;三 、多实例模式&lt;/h1&gt;

&lt;p&gt;多实例模式，只需要复制tomcat实例目录，修改相应配置文件为B项目地址，端口号等信息即可。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>React入门 </title>
      <link>https://www.3afun.com/post/2017/react%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 20 Aug 2017 22:04:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/react%E5%85%A5%E9%97%A8/</guid>
      
        <description>

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;你可以进行一起全局安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo npm install -g create-react-app
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;创建一个应用&#34;&gt;创建一个应用&lt;/h1&gt;

&lt;p&gt;为了创建一个App，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create-react-app react_demo
cd react_demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完毕后，他会在当前目录下创建一个名为 react_demo 的文件夹。&lt;/p&gt;

&lt;p&gt;如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2017/react_01.png&#34; alt=&#34;react_01&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;运行&#34;&gt;运行&lt;/h1&gt;

&lt;p&gt;运行该App，可以执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd react_demo
npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开浏览器即可以看到自动初始化的界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.3afun.com/media/images/2017/react_02.png&#34; alt=&#34;Areact_02&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python requirements.txt的使用</title>
      <link>https://www.3afun.com/post/2017/python-requirements.txt%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 16 Aug 2017 15:32:00 +0800</pubDate>
      
      <guid>https://www.3afun.com/post/2017/python-requirements.txt%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      
        <description>&lt;p&gt;在构建别人项目环境时，经常可以看到requirements.txt，这个文件记录了所依赖的包和版本。作用就是方便在另一台电脑搭建项目环境。那么如何使用呢？&lt;/p&gt;

&lt;p&gt;生成 &lt;em&gt;requirements.txt&lt;/em&gt; 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 &lt;em&gt;requirements.txt&lt;/em&gt; 依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
  </channel>
</rss>